{"fr": [{"content": "<p>Il est plus fr\u00e9quent qu&rsquo;on ne le croit de trouver des images avec un attribut <strong>src</strong> vide. Ceci appara\u00eet sous deux formes :</p><ol><li>En HTML</li></ol><pre><code>&lt;img src=&quot;&quot;&gt;</code></pre><ol><li>En JavaScript</li></ol><pre><code>var img = new Image();img.src = &quot;&quot;;</code></pre><p>Les deux formes ont le m\u00eame effet : le navigateur fait une nouvelle demande \u00e0 votre serveur.</p><ul><li><strong>Internet Explorer</strong> fait une demande pour le r\u00e9pertoire dans lequel se trouve la page.</li><li><strong>Safari et Chrome</strong> font la demande \u00e0 la page elle-m\u00eame.</li><li><strong>Firefox</strong> 3 et les versions ant\u00e9rieures se comportent comme Safari et Chrome, mais la version 3.5 a abord\u00e9 cette question dans le rapport de <a href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=444931\">[bug 444931]</a> et n&rsquo;envoie donc plus de nouvelle demande.</li><li><strong>Op\u00e9ra</strong> ne fait rien.</li></ul><p><strong>Pourquoi est-ce un mauvais comportement ?</strong></p><ol><li>Paralyse vos serveurs en envoyant une grande quantit\u00e9 de trafic inattendu, surtout pour les pages qui obtiennent des millions de pages vues par jour.</li><li>Perte de puissance de calcul pour g\u00e9n\u00e9rer une page qui ne sera jamais vue.</li><li>Donn\u00e9es de l&rsquo;utilisateur \u00e9ventuellement corrompues. Si vous suivez l&rsquo;\u00e9tat de la requ\u00eate, que ce soit par cookies ou d&rsquo;une autre mani\u00e8re, vous avez la possibilit\u00e9 de d\u00e9truire les donn\u00e9es. M\u00eame si la demande d&rsquo;image ne \u200b\u200brenvoie pas d&rsquo;image, tous les en-t\u00eates sont lus et accept\u00e9s par le navigateur, y compris tous les cookies. Alors que le reste de la r\u00e9ponse est rejet\u00e9e, des d\u00e9g\u00e2ts peuvent d\u00e9j\u00e0 \u00eatre faits.</li></ol><p>La cause de ce comportement est la fa\u00e7on dont la r\u00e9solution URI est effectu\u00e9e dans les navigateurs. Ce comportement est d\u00e9fini dans la RFC 3986 - Uniform Resource Identifiers. Quand une cha\u00eene vide est rencontr\u00e9e comme URI, celle-ci est consid\u00e9r\u00e9e comme un URI relatif et est r\u00e9solu selon l&rsquo;algorithme d\u00e9fini dans la section 5.2. Ce cas particulier est d\u00e9taill\u00e9 \u00e0 la section 5.4. Firefox, Safari et Chrome ont tous r\u00e9solu ce probl\u00e8me de cha\u00eene vide correctement dans leur cahier des charges, alors qu&rsquo;Internet Explorer le r\u00e9sout de fa\u00e7on incorrecte, apparemment selon une version ant\u00e9rieure de la sp\u00e9cification, RFC 2396 - Uniform Resource Identifiers (rendue obsol\u00e8te par la RFC 3986). Ainsi, techniquement, les navigateurs font ce qu&rsquo;ils sont cens\u00e9s faire pour r\u00e9soudre les URI relatifs. Le probl\u00e8me est que dans ce contexte, la cha\u00eene vide est clairement involontaire.</p><p>\u00c0 la section 4.8.2, HTML5 ajoute \u00e0 la description de l&rsquo;attribut src de la balise l&rsquo;indication aux navigateurs de ne pas faire une demande suppl\u00e9mentaire :</p><blockquote><p>L&rsquo;attribut src doit \u00eatre pr\u00e9sent et doit contenir une URL valide de r\u00e9f\u00e9rencement d&rsquo;une image, \u00e9ventuellement anim\u00e9e mais non-interactive, ni pagin\u00e9e ou script\u00e9e. Si l&rsquo;URI de base de l&rsquo;\u00e9l\u00e9ment est la m\u00eame que l&rsquo;adresse du document, alors la valeur de l&rsquo;attribut src ne peut pas \u00eatre une cha\u00eene vide.</p></blockquote><p>Heureusement, les navigateurs n&rsquo;auront plus ce probl\u00e8me \u00e0 l&rsquo;avenir. Malheureusement, il n&rsquo;existe pas de telle clause pour <code>&lt;script src=&quot;&quot;&gt;</code> et <code>&lt;link href=&quot;&quot;&gt;</code>. Peut-\u00eatre qu&rsquo;il est encore temps de faire cet ajustement pour s&rsquo;assurer que les navigateurs n&rsquo;impl\u00e9mentent ce comportement par accident.</p><p>Cette r\u00e8gle a \u00e9t\u00e9 inspir\u00e9e par le gourou JavaScript Yahoo! Nicolas C. Zakas. Pour plus d&rsquo;informations, consultez son article &ldquo;<a href=\"http://www.nczonline.net/blog/2009/11/30/empty-image-src-can-destroy-your-site/\">Empty image src can destroy your site</a>&rdquo;.</p>", "id": "yemptysrc", "title": "\u00c9viter les balises image src vides"}, {"content": "<p>Parfois, les pages sont per\u00e7ues comme moins r\u00e9actives \u00e0 cause des trop nombreux gestionnaires d&rsquo;\u00e9v\u00e9nements attach\u00e9s aux diff\u00e9rents \u00e9l\u00e9ments de l&rsquo;arborescence DOM et qui sont ensuite ex\u00e9cut\u00e9s trop souvent. C&rsquo;est pourquoi l&rsquo;utilisation d&rsquo;une <em>d\u00e9l\u00e9gation d&rsquo;\u00e9v\u00e9nement</em> est une bonne approche. Si vous avez 10 boutons \u00e0 l&rsquo;int\u00e9rieur d&rsquo;un <code>div</code>, attachez un seul gestionnaire d&rsquo;\u00e9v\u00e9nements sur le div au lieu d&rsquo;un gestionnaire pour chaque bouton. Les \u00e9v\u00e9nements vont survenir afin que vous soyez en mesure de capturer l&rsquo;\u00e9v\u00e9nement et d\u00e9terminer de quel bouton il provient.</p><p>Vous n&rsquo;avez pas besoin d&rsquo;attendre l&rsquo;\u00e9v\u00e9nement onload pour commencer \u00e0 faire quelque chose avec l&rsquo;arborescence DOM. Souvent, tout ce dont vous avez besoin est que l&rsquo;\u00e9l\u00e9ment auquel vous souhaitez acc\u00e9der soit disponible dans l&rsquo;arbre. Vous n&rsquo;avez pas \u00e0 attendre que toutes les images soient t\u00e9l\u00e9charg\u00e9es. <code>DOMContentLoaded</code> est l&rsquo;\u00e9v\u00e9nement que vous pouvez envisager d&rsquo;utiliser \u00e0 la place de onload, mais jusqu&rsquo;\u00e0 ce qu&rsquo;il soit disponible dans tous les navigateurs, vous pouvez utiliser l&rsquo;utilitaire <a href=\"http://developer.yahoo.com/yui/event/\">YUI Event</a> qui a une m\u00e9thode <code>onAvailable</code>.</p><p>Consultez le YUI theatre&rsquo;s <a href=\"http://yuiblog.com/blog/2007/12/20/video-lecomte/\">&ldquo;High Performance Ajax Applications&rdquo;</a> de Julien Lecomte pour plus d&rsquo;informations.</p>", "id": "yevents", "title": "D\u00e9velopper des gestionnaires d\u2019\u00e9v\u00e9nements intelligents"}, {"content": "<p>Les requ\u00eates HTTP sont ch\u00e8res alors faire une requ\u00eate HTTP et obtenir une r\u00e9ponse telle que &ldquo;404 Not Found&rdquo; est totalement inutile et va ralentir l&rsquo;exp\u00e9rience utilisateur.</p><p>Certains sites ont des pages 404 utiles &ldquo;Vouliez-vous dire &hellip; ?&rdquo;, ce qui est excellent pour l&rsquo;exp\u00e9rience utilisateur mais toujours un gaspillage de ressources serveur (base de donn\u00e9es, etc.). C&rsquo;est particuli\u00e8rement mauvais quand le lien a un JavaScript externe est faux et que le r\u00e9sultat est un 404. Tout d&rsquo;abord, ce t\u00e9l\u00e9chargement va bloquer les t\u00e9l\u00e9chargements parall\u00e8les. De plus, le navigateur peut essayer d&rsquo;analyser le corps de la r\u00e9ponse 404 comme s&rsquo;il s&rsquo;agissait du code JavaScript et en essayant de trouver quelque chose d&rsquo;utilisable en elle.</p>", "id": "yno404", "title": "\u00c9viter les erreurs 404"}, {"content": "<p>Le syst\u00e8me de noms de domaines (DNS) fait correspondre les noms d&rsquo;h\u00f4tes en adresses IP, tout comme les carnets d&rsquo;adresse font correspondre les noms des personnes \u00e0 leurs num\u00e9ros de t\u00e9l\u00e9phone. Lorsque vous tapez www.yahoo.com dans votre navigateur, un r\u00e9solveur DNS contact\u00e9 par le navigateur renvoie l&rsquo;adresse IP de ce serveur. Les requ\u00eates DNS ont un co\u00fbt. Il faut g\u00e9n\u00e9ralement 20 \u00e0 120 millisecondes \u00e0 un serveur DNS pour rechercher l&rsquo;adresse IP d&rsquo;un nom d&rsquo;h\u00f4te donn\u00e9. Le navigateur ne peut rien t\u00e9l\u00e9charger depuis cet h\u00f4te tant que la recherche DNS n&rsquo;est pas termin\u00e9e.</p><p>Les recherches DNS sont mises en cache pour am\u00e9liorer les performances. Cette mise en cache peut se produire sur un serveur de mise en cache d\u00e9di\u00e9 maintenu par le r\u00e9seau du FAI ou local de l&rsquo;utilisateur. Il y a aussi la mise en cache qui se produit sur l&rsquo;ordinateur de l&rsquo;utilisateur. Les informations DNS restent dans le cache DNS du syst\u00e8me d&rsquo;exploitation (le \u00abservice Client DNS\u00bb sur Microsoft Windows). La plupart des navigateurs ont leurs propres caches distincts de la m\u00e9moire cache du syst\u00e8me d&rsquo;exploitation. Tant que le navigateur conserve un enregistrement DNS dans son propre cache, \u00e7a ne d\u00e9range pas le syst\u00e8me d&rsquo;exploitation avec une demande d&rsquo;enregistrement.</p><p>Par d\u00e9faut, Internet Explorer met en cache les recherches DNS pendant 30 minutes, comme sp\u00e9cifi\u00e9 par le param\u00e8tre <code>DnsCacheTimeout</code> de la base des registres. Firefox met en cache les recherches DNS pendant 1 minute, contr\u00f4l\u00e9 par le param\u00e8tre de configuration <code>network.dnsCacheExpiration</code>. (Fasterfox change ce param\u00e8tre \u00e0 1 heure.)</p><p>Lorsque le cache DNS du client est vide (\u00e0 la fois le navigateur et le syst\u00e8me d&rsquo;exploitation), le nombre de requ\u00eates DNS est \u00e9gal au nombre de noms d&rsquo;h\u00f4tes uniques dans la page web. Cela inclut les noms d&rsquo;h\u00f4tes utilis\u00e9s dans l&rsquo;URL de la page, des images, des fichiers de scripts, feuilles de style, objets Flash, etc. R\u00e9duire le nombre de noms d&rsquo;h\u00f4tes uniques r\u00e9duit le nombre de requ\u00eates DNS.</p><p>R\u00e9duire le nombre de noms d&rsquo;h\u00f4tes uniques peut r\u00e9duire le nombre de t\u00e9l\u00e9chargements parall\u00e8les effectu\u00e9s par la page. Limiter les recherches DNS r\u00e9duit les temps de r\u00e9ponse mais la r\u00e9duction du nombre de t\u00e9l\u00e9chargements parall\u00e8les peut augmenter les temps de r\u00e9ponse. Ma ligne directrice est de diviser ces composants sur au moins deux mais pas sur plus de quatre noms d&rsquo;h\u00f4tes. Il en r\u00e9sulte un bon compromis entre r\u00e9duction des requ\u00eates DNS et pourcentage \u00e9lev\u00e9 de t\u00e9l\u00e9chargements parall\u00e8les.</p>", "id": "ydns", "title": "R\u00e9duire le nombre de r\u00e9solutions DNS"}, {"content": "<p>Les redirections sont effectu\u00e9es en utilisant les codes d&rsquo;\u00e9tat 301 et 302. Voici un exemple des en-t\u00eates HTTP dans une r\u00e9ponse 301 :</p><pre><code>HTTP/1.1 301 Moved PermanentlyLocation: http://example.com/newuriContent-Type: text/html</code></pre><p>Vous pouvez jeter un oeil de plus pr\u00e8s \u00e0 votre page et vous vous demandez : \u00abQu&rsquo;est-ce qui est absolument n\u00e9cessaire afin d&rsquo;initier le rendu de la page?\u00bb. Le reste du contenu et des composants peut attendre.</p><p>JavaScript est un candidat id\u00e9al pour la s\u00e9paration avant et apr\u00e8s l&rsquo;\u00e9v\u00e9nement onload. Par exemple, si vous avez du code JavaScript et des biblioth\u00e8ques qui font du glisser-d\u00e9poser et autres animations, celles-ci peuvent attendre. Glisser des \u00e9l\u00e9ments sur la page vient apr\u00e8s le rendu initial. Autres endroits pour chercher des candidats pour le post chargement : le contenu cach\u00e9 (il appara\u00eet apr\u00e8s une action de l&rsquo;utilisateur) et les images en-dessous de la ligne de flottaison.</p><p>Les outils pour vous aider dans votre effort : <a href=\"http://developer.yahoo.com/yui/imageloader/\">YUI Image Loader</a> vous permet de retarder les images sous la ligne de flottaison et le <a href=\"http://developer.yahoo.com/yui/get/\">YUI Get Utility</a> est un moyen facile d&rsquo;inclure du JS et des CSS \u00e0 la vol\u00e9e. Pour voir un exemple, jetez un oeil \u00e0 <a href=\"http://www.yahoo.com\">La page d&rsquo;accueil de Yahoo!</a> avec le panneau r\u00e9seau de Firebug activ\u00e9.</p><p>C&rsquo;est une bonne chose que les objectifs de performance soient en ad\u00e9quation avec d&rsquo;autres bonnes pratiques de d\u00e9veloppement web. Dans ce cas, l&rsquo;id\u00e9e d&rsquo;am\u00e9liorations progressives nous dit que le JavaScript, quand il est support\u00e9, peut am\u00e9liorer l&rsquo;exp\u00e9rience utilisateur. Mais vous devez vous assurer que la page fonctionne m\u00eame sans JavaScript. Ainsi, apr\u00e8s que vous ayez fait en sorte que la page fonctionne, vous pouvez l&rsquo;am\u00e9liorer avec quelques scripts en post-chargement qui donneront plus de peps \u00e0 celle-ci tels que le glisser-d\u00e9poser et les animations.</p>", "id": "ypostload", "title": "Post-charger les composants"}, {"content": "<p>Dans nos recherches sur la performance chez Yahoo!, nous avons d\u00e9couvert que le d\u00e9placement des feuilles de style dans la partie HEAD du document rend les pages <em>apparemment</em> plus rapides \u00e0 charger. C&rsquo;est parce que mettre des feuilles de style dans la partie HEAD d&rsquo;un document permet \u00e0 la page d&rsquo;\u00eatre rendue progressivement.</p><p>Les ing\u00e9nieurs se souciant de performance veulent une page \u00e0 chargement progressif, c&rsquo;est ce que nous voulons pour que le navigateur affiche n&rsquo;importe quel contenu le plus rapidement possible. Ceci est particuli\u00e8rement important pour les pages avec beaucoup de contenu et pour les utilisateurs de connexions Internet lentes. L&rsquo;importance de donner aux utilisateurs un retour visuel, tels que des indicateurs de progr\u00e8s a \u00e9t\u00e9 bien <a href=\"http://www.useit.com/papers/responsetime.html\">document\u00e9</a>. Dans notre cas, la page HTML est l&rsquo;indicateur de progression! Lorsque le navigateur charge la page progressivement, l&rsquo;en-t\u00eate, la barre de navigation, le logo en haut, etc. tous ces \u00e9l\u00e9ments servent de feedback visuel pour l&rsquo;utilisateur qui est en attente de la page. Cela am\u00e9liore l&rsquo;exp\u00e9rience globale de l&rsquo;utilisateur.</p><p>Le probl\u00e8me en mettant les feuilles en bas de document est l&rsquo;interdiction du rendu progressif dans de nombreux navigateurs, y compris Internet Explorer. Ces navigateurs bloquent tout rendu pour \u00e9viter d&rsquo;avoir \u00e0 redessiner des \u00e9l\u00e9ments de la page si leurs styles changent. L&rsquo;utilisateur est scotch\u00e9 une page blanche.</p><p>La <a href=\"http://www.w3.org/TR/html4/struct/links.html#h-12.3\">sp\u00e9cification HTML</a> stipule clairement que les feuilles de style doivent \u00eatre incluses dans la partie HEAD de la page. &ldquo;Contrairement \u00e0 la balise A, la balise [LINK] ne peut appara\u00eetre que dans la section HEAD d&rsquo;un document mais peut appara\u00eetre plusieurs fois.&rdquo; Aucune des alternatives comme les flashs de contenus non styl\u00e9s ou le grand \u00e9cran blanc ne valent de prendre le risque. La solution optimale est de suivre la sp\u00e9cification HTML et de charger vos feuilles de style dans la partie HEAD du document.</p>", "id": "ycsstop", "title": "Mettre les feuilles de style en d\u00e9but de page"}, {"content": "<p>le pr\u00e9chargement peut sembler de prime abord l&rsquo;exact oppos\u00e9 du post-chargement, mais il a en fait un objectif diff\u00e9rent. Le pr\u00e9chargement de composants consiste \u00e0 profiter du temps o\u00f9 le navigateur est inactif pour charger des composants de la demande dont vous aurez besoin plus tard (comme les images, les styles et les scripts). De cette fa\u00e7on, lorsque l&rsquo;internaute visite la page suivante, vous pourriez avoir la plupart des composants d\u00e9j\u00e0 dans le cache et votre page se chargera beaucoup plus rapidement pour l&rsquo;utilisateur.</p><p>Il y a en fait plusieurs types de pr\u00e9chargements :</p><ul><li>Pr\u00e9chargement <em>inconditionnel</em> - d\u00e8s que l&rsquo;\u00e9v\u00e9nement onload se produit, allez-y et r\u00e9cup\u00e9rez quelques composants suppl\u00e9mentaires. V\u00e9rifiez google.com pour voir un exemple de la fa\u00e7on dont une image compos\u00e9e de sprites est demand\u00e9 onload. Cette image compos\u00e9e de sprites n&rsquo;est pas n\u00e9cessaire sur la page d&rsquo;accueil de google.com, mais elle est n\u00e9cessaire sur la page de r\u00e9sultat de recherche cons\u00e9cutive.</li><li>Pr\u00e9chargement <em>conditionnel</em> - bas\u00e9 sur une action de l&rsquo;utilisateur \u00e0 faire une supposition \u00e9clair\u00e9e de la prochaine \u00e9tape de l&rsquo;utilisateur et pr\u00e9charger en cons\u00e9quence. Sur <a href=\"http://search.yahoo.com\">search.yahoo.com</a> vous pouvez voir comment certains composants suppl\u00e9mentaires sont demand\u00e9s apr\u00e8s que vous ayez commenc\u00e9 \u00e0 taper dans la zone de saisie.</li><li>Pr\u00e9chargement <em>pr\u00e9vu</em> - pr\u00e9charge \u00e0 l&rsquo;avance avant de lancer une refonte du design d&rsquo;un site. Il arrive souvent apr\u00e8s une refonte que vous entendiez : \u00abLe nouveau site est cool, mais il est plus lent qu&rsquo;avant\u00bb. Une partie du probl\u00e8me pourrait \u00eatre que les utilisateurs \u00e9taient en visite sur votre ancien site avec un cache complet, mais le nouveau est toujours parcouru avec un cache vide. Vous pouvez att\u00e9nuer cet effet secondaire par le pr\u00e9chargement des composants avant m\u00eame de lancer la refonte. Votre ancien site utilise le temps pendant lequel le navigateur est inactif pour demander des images et des scripts qui seront utilis\u00e9s par le nouveau site.</li></ul>", "id": "ypreload", "title": "Pr\u00e9charger les composants"}, {"content": "<p>Une des meilleures pratiques pr\u00e9c\u00e9dentes indique que les feuilles de style CSS devraient \u00eatre charg\u00e9es en haut de page afin de permettre le rendu progressif.</p><p>Dans IE <code>@import</code> se comporte comme utilisant <code>&lt;link&gt;</code> en bas de page, il est donc pr\u00e9f\u00e9rable de ne pas l&rsquo;utiliser.</p>", "id": "ycsslink", "title": "Utiliser &lt;link&gt; plut\u00f4t que @import"}, {"content": "<p>Cette restriction est li\u00e9e au fait que l&rsquo;iPhone ne mettra pas en cache de composants plus grands que 25K. Notez que c&rsquo;est la taille <em>non compress\u00e9e</em>. C&rsquo;est l\u00e0 o\u00f9 la minification est importante parce que gzip seul peut ne pas suffire.</p><p>Pour plus d&rsquo;informations, consultez &ldquo;<a href=\"http://yuiblog.com/blog/2008/02/06/iphone-cacheability/\">Performance Research, Part 5: iPhone Cacheability - Making it Stick</a>&rdquo; par Wayne Shea et Tenni Theurer.</p>", "id": "yunder25", "title": "Garder les composants sous les 25 KO"}, {"content": "<p>Les balises d&rsquo;entit\u00e9s (ETAG) sont un m\u00e9canisme que les serveurs web et les navigateurs utilisent pour d\u00e9terminer si le composant dans le cache du navigateur correspond \u00e0 celui sur le serveur d&rsquo;origine (Une \u00abentit\u00e9\u00bb est un autre mot pour d\u00e9signer un \u00abcomposant\u00bb : image, script, feuille de style, etc). Les ETags ont \u00e9t\u00e9 ajout\u00e9s pour fournir un m\u00e9canisme de validation des entit\u00e9s qui est plus souple que la date de derni\u00e8re modification. Un ETag est une cha\u00eene qui identifie de mani\u00e8re unique une version sp\u00e9cifique d&rsquo;un composant. Les seules contraintes de format sont que la cha\u00eene soit indiqu\u00e9e entre guillements. Le serveur d&rsquo;origine sp\u00e9cifie le ETag du composant en utilisant <code>ETag</code> dans l&rsquo;en-t\u00eate de r\u00e9ponse.</p><pre><code>HTTP/1.1 200 OKLast-Modified: Tue, 12 Dec 2006 03:03:59 GMTETag: &quot;10c24bc-4ab-457e1c1f&quot;Content-Length: 12195</code></pre><p>Plus tard, si le navigateur doit valider un composant, il utilise l&rsquo;en-t\u00eate <code>If-None-Match</code> pour passer le ETag vers le serveur d&rsquo;origine. Si les ETags correspondent, un code de statut 304 est renvoy\u00e9, \u00e9conomisant 12 195 octets dans la r\u00e9ponse pour cet exemple.</p><pre><code>GET /i/yahoo.gif HTTP/1.1Host: us.yimg.comIf-Modified-Since: Tue, 12 Dec 2006 03:03:59 GMTIf-None-Match: &quot;10c24bc-4ab-457e1c1f&quot;HTTP/1.1 304 Not Modified</code></pre><p>Le probl\u00e8me avec les ETags est qu&rsquo;ils sont g\u00e9n\u00e9ralement construits en utilisant des attributs qui les rendent uniques \u00e0 un serveur, unique \u00e0 l&rsquo;h\u00e9bergement d&rsquo;un site. Les ETags ne correspondent pas lorsqu&rsquo;un navigateur obtient le composant d&rsquo;origine d&rsquo;un serveur et essaie de valider ce composant sur \u200b\u200bun serveur diff\u00e9rent, une situation tr\u00e8s fr\u00e9quente sur \u200b\u200bles sites Web qui utilisent un cluster de serveurs pour traiter les demandes. Par d\u00e9faut, Apache et IIS int\u00e9grent les donn\u00e9es dans le ETag, ce qui r\u00e9duit consid\u00e9rablement les chances de r\u00e9ussite des tests de validit\u00e9 sur les sites Web avec plusieurs serveurs.</p><p>Le format ETag pour Apache 1.3 et 2.x est <code>inode-size-timestamp</code>. M\u00eame si un fichier peut r\u00e9sider dans le m\u00eame r\u00e9pertoire sur plusieurs serveurs, et avoir la m\u00eame taille, les m\u00eames permissions et le m\u00eame horodatage, son inode est diff\u00e9rent d&rsquo;un serveur \u00e0 un autre.</p><p>IIS 5.0 et 6.0 ont un probl\u00e8me semblable avec ETags. Le format de ETags sur IIS est <code>Filetimestamp:ChangeNumber</code>. <code>ChangeNumber</code> est un compteur utilis\u00e9 pour suivre les changements de configuration de IIS. Il est peu probable que le <code>ChangeNumber</code> soit le m\u00eame sur tous les serveurs IIS derri\u00e8re un site web.</p><p>Le r\u00e9sultat final pour les ETags g\u00e9n\u00e9r\u00e9s par Apache et IIS pour le m\u00eame composant ne correspondent pas d&rsquo;un serveur \u00e0 un autre. Si les ETags ne correspondent pas, l&rsquo;utilisateur ne re\u00e7oit pas la petite et rapide r\u00e9ponse 304 pour lesquels ils ont \u00e9t\u00e9 pr\u00e9vus. Au contraire, ils obtiendront une r\u00e9ponse normale 200 avec toutes les donn\u00e9es pour le composant. Si vous h\u00e9bergez votre site web sur un seul serveur, ce n&rsquo;est pas un probl\u00e8me. Mais si vous avez plusieurs serveurs d&rsquo;h\u00e9bergement pour votre site web, et que vous utilisez Apache ou IIS avec la configuration ETag par d\u00e9faut, les utilisateurs ont des pages plus lentes, vos serveurs ont une charge plus \u00e9lev\u00e9e, vous consommez plus de bande passante, et les proxies ne peuvent mettre en cache votre contenu de mani\u00e8re efficace. M\u00eame si vos composants ont un en-t\u00eate <code>Expire</code> lointain, une requ\u00eate GET conditionnelle est toujours faite \u00e0 chaque fois que l&rsquo;utilisateur appuie sur Recharger ou Actualiser.</p><p>Si vous ne tirez pas parti du mod\u00e8le de validation flexible que les ETags fournissent, il est pr\u00e9f\u00e9rable de simplement retirer les ETag partout. L&rsquo;en-t\u00eate <code>Last-Modified</code> valide sur la base de l&rsquo;horodatage du composant. Retirer les ETag r\u00e9duit \u00e0 la fois la taille des en-t\u00eates HTTP de la r\u00e9ponse et des demandes ult\u00e9rieures. Cet <a href=\"http://support.microsoft.com/?id=922733\">article du support technique Microsoft</a> d\u00e9crit comment supprimer les ETags. Dans Apache, cela se fait simplement en ajoutant la ligne suivante \u00e0 votre fichier de configuration d&rsquo;Apache :</p><pre><code> FileETag none</code></pre>", "id": "yetags", "title": "Configurer les ETags"}, {"content": "<p>Inclure le m\u00eame fichier JavaScript \u00e0 deux reprises dans une seule page nuit \u00e0 la performance. Ce n&rsquo;est pas aussi rare qu&rsquo;on pourrait le penser. Un examen des dix meilleurs sites web am\u00e9ricains montre que deux d&rsquo;entre eux contiennent un script dupliqu\u00e9. Deux principaux facteurs augmentent les chances d&rsquo;un script d&rsquo;\u00eatre dupliqu\u00e9 dans une page Web : la taille de l&rsquo;\u00e9quipe et le nombre de scripts. Lorsque cela arrive, le doublon met \u00e0 mal les performances en cr\u00e9ant des requ\u00eates HTTP inutiles et l&rsquo;ex\u00e9cution de code JavaScript perdu.</p><p>Des requ\u00eates HTTP inutiles se produisent dans Internet Explorer mais pas dans Firefox. Dans Internet Explorer, si un script externe est inclus deux fois et n&rsquo;est pas mis en cache, il g\u00e9n\u00e8re deux requ\u00eates HTTP lors du chargement de la page. M\u00eame si le script est mis en cache, des requ\u00eates HTTP suppl\u00e9mentaires se produisent lorsque l&rsquo;utilisateur recharge la page.</p><p>En plus de g\u00e9n\u00e9rer des requ\u00eates HTTP inutiles, du temps est perdu \u00e0 interpr\u00e9ter le script plusieurs fois. Cette ex\u00e9cution JavaScript redondante se passe dans Firefox et Internet Explorer, ind\u00e9pendamment du fait que le script est mis en cache.</p><p>Une fa\u00e7on d&rsquo;\u00e9viter d&rsquo;inclure accidentellement le m\u00eame script deux fois est de mettre en place un module de gestion de scripts dans votre syst\u00e8me de templates. La mani\u00e8re typique d&rsquo;inclure un script est d&rsquo;utiliser la balise SCRIPT dans votre page HTML.</p><pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;menu_1.0.17.js&quot;&gt;&lt;/script&gt;</code></pre><p>Une alternative en PHP serait de cr\u00e9er une fonction appel\u00e9e <code>insertScript</code>.</p><pre><code>&lt;?php insertScript(&quot;menu.js&quot;) ?&gt;</code></pre><p>En plus de pr\u00e9venir le m\u00eame script d&rsquo;\u00eatre ins\u00e9r\u00e9 \u00e0 plusieurs reprises, cette fonction pourrait traiter d&rsquo;autres choses avec des scripts, tels que le contr\u00f4le des d\u00e9pendances et l&rsquo;ajout de num\u00e9ros de version pour les noms de fichiers de scripts. Ceci afin de b\u00e9n\u00e9ficer des en-t\u00eates Expire.</p>", "id": "ydupes", "title": "Supprimer les scripts en doublons"}, {"content": "<p>Les iframes permettent d&rsquo;ins\u00e9rer un document HTML dans le document parent. Il est important de comprendre comment fonctionnent les iframes afin de les utiliser efficacement.</p><p>Les &ldquo;pour&rdquo; :</p><ul><li>Aide avec les contenus tiers lents (scripts, badges, publicit\u00e9s)</li><li>Bac \u00e0 sable de s\u00e9curit\u00e9</li><li>T\u00e9l\u00e9chargement des scripts en parall\u00e8le</li></ul><p>Les &ldquo;contre&rdquo; :</p><ul><li>Co\u00fbte cher m\u00eame si vide</li><li>Bloque l&rsquo;\u00e9v\u00e9nement onload</li><li>Pas s\u00e9mantique</li></ul>", "id": "yiframes", "title": "Minimiser le nombre de iframes"}, {"content": "<p>Beaucoup des r\u00e8gles de performance traitent de la fa\u00e7on dont les composants externes sont g\u00e9r\u00e9s. Toutefois, avant que ces \u00e9l\u00e9ments apparaissent, vous devez vous poser une question plus fondamentale : les scripts JavaScript et les feuilles de style CSS doivent-ils \u00eatre contenus dans des fichiers externes ou en ligne dans la page elle-m\u00eame ?</p><p>L&rsquo;utilisation des fichiers externes produit g\u00e9n\u00e9ralement des pages plus rapides parce que les fichiers JavaScript et CSS sont mis en cache par le navigateur. JavaScript et CSS en ligne dans les documents HTML sont t\u00e9l\u00e9charg\u00e9s chaque fois que le document HTML est demand\u00e9. Cela r\u00e9duit le nombre de requ\u00eates HTTP n\u00e9cessaires mais augmente la taille du document HTML. D&rsquo;autre part, si le code JavaScript et CSS dans des fichiers externes est mis en cache par le navigateur, la taille du document HTML est r\u00e9duite sans augmenter le nombre de requ\u00eates HTTP.</p><p>Le facteur-cl\u00e9 est donc la fr\u00e9quence avec laquelle les composants CSS et JavaScript externes sont mis en cache par rapport au nombre de documents HTML demand\u00e9s. Ce facteur, bien que difficile \u00e0 quantifier, peut \u00eatre mesur\u00e9 \u00e0 l&rsquo;aide de divers param\u00e8tres. Si les utilisateurs de votre site voient plusieurs pages par session et que nombre de celles-ci r\u00e9-utilisent les m\u00eames scripts et feuilles de style, alors il y a un plus grand b\u00e9n\u00e9fice potentiel \u00e0 utiliser des fichiers externes en cache.</p><p>De nombreux sites Web \u00e9chouent sur ces mesures. Pour ces sites, la meilleure solution consiste g\u00e9n\u00e9ralement \u00e0 d\u00e9ployer le code JavaScript et les feuilles de style CSS dans des fichiers externes. La seule exception o\u00f9 les mettre en ligne est pr\u00e9f\u00e9rable est les pages d&rsquo;accueil, tels que <a href=\"http://www.yahoo.com\">Yahoo!</a> et <a href=\"http://my.yahoo.com\">Mon Yahoo! </a>. Les pages d&rsquo;accueil qui ont peu de vues (voir une seule) par session peuvent trouver que JavaScript et CSS en ligne r\u00e9sultent dans des temps de r\u00e9ponse plus rapides pour l&rsquo;utilisateur final.</p><p>Pour les pages d&rsquo;accueil qui sont g\u00e9n\u00e9ralement les premi\u00e8res d&rsquo;une suite de pages vues, il existe des techniques qui s&rsquo;appuient sur la r\u00e9duction de requ\u00eates HTTP que fournit le mode en ligne ainsi que les avantages de la mise en cache obtenus gr\u00e2ce \u00e0 l&rsquo;utilisation de fichiers externes. Une de ces techniques consiste \u00e0 charger en ligne le JavaScript et les CSS dans la page d&rsquo;accueil mais en t\u00e9l\u00e9chargeant dynamiquement les fichiers externes apr\u00e8s le chargment de la page. Les pages suivantes pourraient alors r\u00e9f\u00e9rencer les fichiers externes qui devraient d\u00e9j\u00e0 \u00eatre dans le cache du navigateur.</p>", "id": "yexternal", "title": "Rendre JavaScript et les CSS externes"}, {"content": "<p>Les cookies HTTP sont utilis\u00e9s pour de multiples raisons comme l&rsquo;authentification et la personnalisation. L&rsquo;information sur les cookies est \u00e9chang\u00e9e dans les en-t\u00eates HTTP entre les serveurs Web et les navigateurs. Il est important de garder la taille des cookies aussi basse que possible pour minimiser l&rsquo;impact sur \u200b\u200ble temps de r\u00e9ponse de l&rsquo;utilisateur.</p><p>Consultez <a href=\"http://yuiblog.com/blog/2007/03/01/performance-research-part-3/\">&ldquo;When the Cookie Crumbles&rdquo;</a> par Tenni Theurer et Patty Chi pour plus d&rsquo;informations. Les points importants de cette recherche :</p><ul><li>\u00c9liminer les cookies inutiles.</li><li>Gardez leur taille aussi faible que possible afin de minimiser l&rsquo;impact sur le temps de r\u00e9ponse de l&rsquo;utilisateur.</li><li>Stockez vos cookies au niveau de domaine appropri\u00e9 afin que les autres sous-domaines ne soient pas affect\u00e9s.</li><li>D\u00e9finir une date d&rsquo;expiration appropri\u00e9e. Un d\u00e9lai d&rsquo;expiration plus court ou aucune date d&rsquo;expiration sp\u00e9cifi\u00e9e feront expirer le cookie plus t\u00f4t, am\u00e9liorant par l\u00e0 le temps de r\u00e9ponse de l&rsquo;utilisateur.</li></ul>", "id": "ymincookie", "title": "R\u00e9duire la taille des cookies"}, {"content": "<p>Les expressions CSS sont un moyen puissant (et dangereux) pour d\u00e9finir des propri\u00e9t\u00e9s CSS dynamiquement. Elles ont \u00e9t\u00e9 prises en charge dans Internet Explorer \u00e0 partir de la version 5, mais ont \u00e9t\u00e9 rendues <a href=\"http://msdn.microsoft.com/en-us/library/ms537634%28VS.85%29.aspx\">obsol\u00e8tes \u00e0 partir de IE8</a>. Par exemple, la couleur de fond peut \u00eatre configur\u00e9e pour alterner toutes les heures en utilisant une expression CSS :</p><pre><code>background-color: expression( (new Date()).getHours()%2 ? &quot;#B8D4FF&quot; : &quot;#F08A00&quot; );</code></pre><p>Comme d\u00e9montr\u00e9 ci-dessus, la m\u00e9thode <code>expression</code> accepte une expression JavaScript. La propri\u00e9t\u00e9 CSS est r\u00e9gl\u00e9e sur le r\u00e9sultat de l&rsquo;\u00e9valuation de l&rsquo;expression JavaScript. La m\u00e9thode <code>expression</code> est ignor\u00e9e par les autres navigateurs, elle est donc utile pour d\u00e9finir les propri\u00e9t\u00e9s d&rsquo;Internet Explorer n\u00e9cessaires pour cr\u00e9er une exp\u00e9rience coh\u00e9rente \u00e0 travers les autres navigateurs.</p><p>Le probl\u00e8me avec les expressions, c&rsquo;est qu&rsquo;elles sont \u00e9valu\u00e9es plus souvent que ce \u00e0 quoi la plupart des gens pourraient s&rsquo;attendre. Non seulement elles sont \u00e9valu\u00e9es lorsque la page est rendue et redimensionn\u00e9e mais aussi lorsque la page d\u00e9file et m\u00eame lorsque l&rsquo;utilisateur d\u00e9place la souris sur la page. Ajouter un compteur \u00e0 l&rsquo;expression CSS nous permet de garder une trace de quand et combien de fois une expression CSS est \u00e9valu\u00e9e. D\u00e9placer la souris dans la page peut facilement g\u00e9n\u00e9rer plus de 10.000 \u00e9valuations.</p><p>Une fa\u00e7on de r\u00e9duire le nombre de fois que votre expression CSS est \u00e9valu\u00e9e est d&rsquo;utiliser des expressions uniques dans le temps. La premi\u00e8re fois l&rsquo;expression est \u00e9valu\u00e9e, elle d\u00e9finit la propri\u00e9t\u00e9 de style pour une valeur explicite qui remplace l&rsquo;expression CSS. Si la propri\u00e9t\u00e9 de style doit \u00eatre d\u00e9finie de fa\u00e7on dynamique tout au long de la vie de la page, utilisez comme approche alternative des gestionnaires d&rsquo;\u00e9v\u00e9nements au lieu d&rsquo;expressions CSS. Si vous devez utiliser des expressions CSS, rappelez-vous qu&rsquo;elles peuvent \u00eatre \u00e9valu\u00e9es des milliers de fois et pourraient affecter la performance de votre page.</p>", "id": "yexpressions", "title": "\u00c9viter les expressions CSS"}, {"content": "<p>Quand le designer en a fini avec la cr\u00e9ation des images pour votre page web, il y a encore certaines choses que vous pouvez essayer de faire avant d&rsquo;envoyer les images sur votre serveur web.</p><ul><li>Vous pouvez v\u00e9rifier les images GIF et voir si elles utilisent une taille de palette correspondant au nombre de couleurs dans l&rsquo;image. L&rsquo;utilisation de <a href=\"http://www.imagemagick.org\">imagemagick</a> rend cette v\u00e9rification facile en utilisant <code>identifier-verbose image.gif</code> Lorsque vous voyez une image de 4 couleurs utilisant une palette de 256 couleurs, il y a mati\u00e8re \u00e0 am\u00e9lioration.</li><li>Essayez de convertir les fichiers GIF en PNG pour voir si la taille diminue. C&rsquo;est le cas plus souvent qu&rsquo;on ne le croit. Les d\u00e9veloppeurs h\u00e9sitent souvent \u00e0 utiliser le format PNG en raison de sa prise en charge limit\u00e9e dans les navigateurs. C&rsquo;est maintenant du pass\u00e9. Le seul vrai probl\u00e8me est la transparence alpha dans les couleurs vraies PNG. Mais l\u00e0 encore, GIF ne ne fait pas mieux et ne prend pas en charge la transparence variable. Donc, tout ce que GIF peut faire, une palette PNG (PNG8) peut le faire (sauf pour les animations). Cette simple commande <code>imagemagick</code> donne un PNG totalement s\u00fbr \u00e0 utiliser: <code>convert image.gif image.png</code> &ldquo;Tout ce que nous disons, c&rsquo;est : donnez une chance au PiNG !&rdquo;</li><li>Ex\u00e9cutez <a href=\"http://pmt.sourceforge.net/pngcrush/\">pngcrush</a> ou tout autre outil d&rsquo;optimisation PNG sur tous vos PNG. Exemple: <code>pngcrush image.png -rem alla -reduce -brute result.png</code></li><li>Ex\u00e9cutez <code>jpegtran</code> sur tous vos fichiers JPEG. Cet outil effectue des op\u00e9rations JPEG sans perte comme la rotation et peut \u00e9galement \u00eatre utilis\u00e9 pour optimiser et supprimer commentaires et autres informations inutiles (telles que les informations EXIF) de vos images. <code>jpegtran -copy none -optimize -perfect src.jpg dest.jpg</code>.</li></ul>", "id": "yopt_images", "title": "Optimiser les images"}, {"content": "<ul><li>Organisez les images dans l&rsquo;image-objet horizontalement plut\u00f4t que verticalement donne en g\u00e9n\u00e9ral un fichier de plus petite taille.</li><li>La combinaison de couleurs similaires dans un sprite vous aide \u00e0 n&rsquo;utiliser que peu de couleurs, id\u00e9alement moins de 256 afin d&rsquo;int\u00e9grer un PNG8.</li><li>&ldquo;Soyez mobile-friendly&rdquo; et ne laissez pas de grands espaces entre les images d&rsquo;un sprite. Cela n&rsquo;affecte pas tant que \u00e7a la taille du fichier mais n\u00e9cessite moins de m\u00e9moire au terminal utilisateur pour d\u00e9compresser l&rsquo;image en une carte de pixels. Une image de 100x100 repr\u00e9sente 10000 pixels l\u00e0 o\u00f9 une image de 1000x1000 est compos\u00e9e de 1 millions de pixels.</li></ul>", "id": "yopt_sprites", "title": "Optimiser les sprites CSS"}, {"content": "<p>Lorsque le navigateur envoie une requ\u00eate pour une image statique et envoie un/des cookie(s) avec la demande, le serveur n&rsquo;a pas l&rsquo;utilit\u00e9 de ces cookies. Ils cr\u00e9ent du trafic r\u00e9seau sans raison valable. Vous devez vous assurer que les composants statiques soient demand\u00e9s sans cookies. Cr\u00e9ez un sous-domaine et h\u00e9bergez-y tous vos composants statiques.</p><p>Si votre domaine est <code>www.example.org</code>, vous pouvez h\u00e9berger vos composants statiques sur <code>static.example.org</code>. Toutefois, si vous avez d\u00e9j\u00e0 configur\u00e9 les cookies sur le domaine de premier niveau <code>example.org</code> par opposition \u00e0 <code>www.example.org</code>, alors toutes les demandes vers <code>static.example.org</code> comprendront des cookies. Dans ce cas, vous pouvez acheter un tout nouveau domaine, y h\u00e9berger vos composants statiques et garder ce nom de domaine libre de tout cookie. Yahoo! utilise <code>yimg.com</code>, YouTube utilise <code>ytimg.com</code>, Amazon utilise <code>image-amazon.com</code> et ainsi de suite.</p><p>Un autre avantage de mettre les composants statiques sur un domaine sans cookie est que certains mandataires pourraient refuser de mettre en cache les composants demand\u00e9s avec des cookies. Sur une note li\u00e9e, si vous vous demandez si vous devez utiliser example.org ou www.example.org pour votre page d&rsquo;accueil, envisagez l&rsquo;impact des cookies. Omettre www ne vous laisse pas d&rsquo;autre choix que d&rsquo;\u00e9crire des cookies pour <code>*.example.org</code>. Pour des raisons de performances, il est pr\u00e9f\u00e9rable d&rsquo;utiliser le sous-domaine www et d&rsquo;\u00e9crire les cookies sur ce sous-domaine.</p>", "id": "ycookiefree", "title": "Utiliser des domaines sans cookies pour les composants"}, {"content": "<p>Un des avantages cit\u00e9s d&rsquo;Ajax est qu&rsquo;il fournit une r\u00e9troaction instantan\u00e9e \u00e0 l&rsquo;utilisateur car il demande des informations de mani\u00e8re asynchrone \u00e0 partir du serveur Web. Cependant, utiliser Ajax n&rsquo;est pas une garantie que l&rsquo;utilisateur ne sera pas en train de se tourner les pouces en attendant le retour des r\u00e9ponses Asynchronous JavaScript and XML. Dans de nombreuses applications, maintenir l&rsquo;attente de l&rsquo;utilisateur d\u00e9pend de la fa\u00e7on dont Ajax est utilis\u00e9. Par exemple, dans un client de messagerie bas\u00e9 sur le Web, l&rsquo;utilisateur sera maintenu en attendant les r\u00e9sultats d&rsquo;une requ\u00eate Ajax pour trouver tous les messages \u00e9lectroniques correspondant aux crit\u00e8res de recherche. Il est important de se rappeler que \u00abasynchrone\u00bb ne signifie pas \u00abinstantan\u00e9\u00bb.</p><p>Pour am\u00e9liorer les performances, il est important d&rsquo;optimiser ces r\u00e9ponses Ajax. Le moyen le plus important pour am\u00e9liorer les performances Ajax est de servir les r\u00e9ponses mises en cache, comme indiqu\u00e9 dans <a href=\"# expire\">Ajouter une expiration ou un en-t\u00eate Cache-Control</a>. D&rsquo;autres r\u00e8gles s&rsquo;appliquent \u00e9galement \u00e0 pour Ajax:</p><ul><li><a href=\"#gzip\">Gzipper les composants</a></li><li><a href=\"#dns_lookups\">R\u00e9duire le nombre de requ\u00eates DNS</a></li><li><a href=\"#minify\">Minifier JavaScript</a></li><li><a href=\"#redirects\">\u00c9viter les redirections</a></li><li><a href=\"#etags\">Configurer les ETags</a></li></ul><p>Voyons un exemple. Un client de messagerie Web 2.0 peut utiliser Ajax pour t\u00e9l\u00e9charger le carnet d&rsquo;adresses de l&rsquo;utilisateur \u00e0 des fins d&rsquo;auto-compl\u00e9tion. Si l&rsquo;utilisateur n&rsquo;a pas modifi\u00e9 son carnet d&rsquo;adresse depuis la derni\u00e8re fois, la r\u00e9ponse du carnet d&rsquo;adresses pr\u00e9c\u00e9dente pourrait \u00eatre lue \u00e0 partir du cache si cette r\u00e9ponse Ajax a \u00e9t\u00e9 mise en cache avec un en-t\u00eate Expire ou Cache-Control. Le navigateur doit \u00eatre inform\u00e9 quand utiliser une r\u00e9ponse de carnet d&rsquo;adresses pr\u00e9c\u00e9demment mise en cache par rapport \u00e0 en demander une nouvelle. Cela pourrait se faire par l&rsquo;ajout d&rsquo;un horodatage dans le carnet d&rsquo;adresse URL Ajax indiquant la derni\u00e8re fois que l&rsquo;utilisateur a modifi\u00e9 son carnet d&rsquo;adresses. Par exemple, <code>&amp;t=1190241612</code>. Si le carnet d&rsquo;adresses n&rsquo;a pas \u00e9t\u00e9 modifi\u00e9 depuis le dernier t\u00e9l\u00e9chargement, l&rsquo;horodatage sera le m\u00eame et le carnet d&rsquo;adresses sera lu \u00e0 partir de la m\u00e9moire cache du navigateur, \u00e9liminant un aller-retour HTTP suppl\u00e9mentaire. Si l&rsquo;utilisateur a modifi\u00e9 son carnet d&rsquo;adresses, l&rsquo;horodatage assure que la nouvelle URL ne correspond pas \u00e0 la r\u00e9ponse mise en cache, et le navigateur demandera une nouvelle r\u00e9ponse du carnet d&rsquo;adresses \u00e0 jour .</p><p>M\u00eame si vos r\u00e9ponses Ajax sont cr\u00e9\u00e9es dynamiquement, et qu&rsquo;elles ne sontt applicables qu&rsquo;\u00e0 un seul utilisateur, elles peuvent encore \u00eatre mises en cache. Cela rendra vos applications Web 2.0 plus rapides.</p>", "id": "yxhr", "title": "Rendre les requ\u00eates Ajax cachables"}, {"content": "<p>Lorsque les utilisateurs demandent une page, il peut se passer 200 \u00e0 500 ms sur le serveur pour assembler la page HTML. Pendant ce temps, le navigateur est inactif, en attente des donn\u00e9es qui vont arriver. En PHP vous avez la fonction <a href=\"http://php.net/flush\">flush()</a>. Elle vous permet d&rsquo;envoyer une partie de la r\u00e9ponse HTML afin que le navigateur puisse commencer la r\u00e9cup\u00e9ration des composants pendant que votre serveur web est occup\u00e9 avec le reste de la page HTML. L&rsquo;avantage est surtout visible sur les serveurs assez charg\u00e9s et sur les clients l\u00e9gers.</p><p>Un bon endroit pour nettoyer le tampon est juste apr\u00e8s la partie HEAD du document. Le code HTML contenu dans cette partie est g\u00e9n\u00e9ralement plus facile \u00e0 produire et il vous permet d&rsquo;inclure tous les fichiers CSS et JavaScript. Le navigateur peut commencer \u00e0 charger en parall\u00e8le alors que le serveur web est en cours de traitement.</p><p>Exemple:</p><pre><code>    ... &lt;!-- css, js --&gt;    &lt;/head&gt;    &lt;?php flush(); ?&gt;    &lt;body&gt;      ... &lt;!-- content --&gt;</code></pre><p><a href=\"http://search.yahoo.com\">Yahoo! search</a> a \u00e9t\u00e9 un des pionniers au niveau recherche sur les tests utilisateurs afin de prouver les avantages de l&rsquo;utilisation de cette technique.</p>", "id": "yflush", "title": "Nettoyer le tampon tr\u00e8s t\u00f4t"}, {"content": "<p>Une page complexe signifie plus d&rsquo;octets \u00e0 t\u00e9l\u00e9charger et aussi un acc\u00e8s au DOM plus lent en JavaScript. Cela fait une diff\u00e9rence si vous parcourez 500 ou 5000 \u00e9l\u00e9ments DOM sur la page lorsque vous souhaitez ajouter un gestionnaire d&rsquo;\u00e9v\u00e9nements par exemple.</p><p>Un nombre \u00e9lev\u00e9 d&rsquo;\u00e9l\u00e9ments DOM peut \u00eatre un sympt\u00f4me qu&rsquo;il ya quelque chose qui devrait \u00eatre am\u00e9lior\u00e9 avec le balisage de la page sans n\u00e9cessairement supprimer du contenu. Utilisez-vous des tableaux imbriqu\u00e9s \u00e0 des fins de mise en page ? Ajoutez-vous plus de balises <code>&lt;div&gt;</code> seulement pour r\u00e9soudre des probl\u00e8mes de mise en page ? Peut-\u00eatre y a t&rsquo;il une meilleure fa\u00e7on, s\u00e9mantiquement plus correcte, de faire votre balisage.</p><p>Les <a href=\"http://developer.yahoo.com/yui/\">YUI CSS utilitaires</a> sont une aide pr\u00e9cieuse pour la mise en page : grids.css peut vous aider pour la disposition g\u00e9n\u00e9rale, fonts.css et reset.css peuvent vous aider \u00e0 red\u00e9finir la mise en forme par d\u00e9faut du navigateur. C&rsquo;est une chance de repartir de z\u00e9ro et de r\u00e9fl\u00e9chir \u00e0 votre balisage, par exemple utilisez des <code>&lt;div&gt;</code> seulement quand c&rsquo;est logique s\u00e9mantiquement et non parce que la balise rend une nouvelle ligne.</p><p>Le nombre d&rsquo;\u00e9l\u00e9ments DOM est facile \u00e0 tester, il suffit de taper dans la console de Firebug : <code>document.getElementsByTagName('*').length</code>.</p><p>Et combien d&rsquo;\u00e9l\u00e9ments DOM sont trop nombreux ? V\u00e9rifiez d&rsquo;autres pages similaires poss\u00e9dant un bon balisage. Par exemple, <a href=\"http://www.yahoo.com\">Yahoo!</a> est une page tr\u00e8s charg\u00e9e et reste pourtant sous la barre des 700 \u00e9l\u00e9ments (balises HTML).</p>", "id": "ymindom", "title": "R\u00e9duire le nombre d\u2019\u00e9l\u00e9ments du DOM"}, {"content": "<p>Le temps n\u00e9cessaire pour transf\u00e9rer une requ\u00eate HTTP et la r\u00e9ponse sur le r\u00e9seau peut \u00eatre sensiblement r\u00e9duit par les d\u00e9cisions prises par les ing\u00e9nieurs front-end. Il est vrai que la vitesse de la bande passante de l&rsquo;utilisateur final, le fournisseur de services Internet, la proximit\u00e9 des points de peering de change, etc. sont hors du contr\u00f4le de l&rsquo;\u00e9quipe de d\u00e9veloppement. Mais il y a d&rsquo;autres variables qui influent sur le temps de r\u00e9ponse. La compression r\u00e9duit les temps de r\u00e9ponse en diminuant la taille de la r\u00e9ponse HTTP.</p><p>\u00c0 partir de HTTP/1.1, les clients Web indiquent leur support de la compression avec l&rsquo;en-t\u00eate Accept-Encoding dans la requ\u00eate HTTP.</p><pre><code>Accept-Encoding: gzip, deflate</code></pre><p>Si le serveur Web voit cet en-t\u00eate dans la demande, il peut compresser la r\u00e9ponse en utilisant l&rsquo;une des m\u00e9thodes \u00e9num\u00e9r\u00e9es par le client. Le serveur web informe le client Web de cette compression via l&rsquo;en-t\u00eate Content-Encoding dans la r\u00e9ponse.</p><pre><code>Content-Encoding: gzip</code></pre><p>Gzip est la m\u00e9thode de compression la plus populaire et efficace pour le moment. Elle a \u00e9t\u00e9 d\u00e9velopp\u00e9e par le projet GNU et normalis\u00e9e par la <a href=\"http://www.ietf.org/rfc/rfc1952.txt\">RFC 1952</a>. Le seul autre format de compression que vous pourriez rencontrer est deflate, mais il est moins efficace et moins populaire.</p><p>Utiliser Gzip diminue g\u00e9n\u00e9ralement la taille de la r\u00e9ponse d&rsquo;environ 70%. Environ 90% du trafic Internet d&rsquo;aujourd&rsquo;hui se d\u00e9place \u00e0 travers des navigateurs qui pr\u00e9tendent supporter gzip. Si vous utilisez Apache, le module d\u00e9di\u00e9 \u00e0 gzip d\u00e9pend de votre version : Apache 1.3 utilise <a href=\"http://sourceforge.net/projects/mod-gzip/\">mod_gzip</a> alors qu&rsquo;Apache 2.x utilise <a href=\"http://httpd.apache.org/docs/2.0/mod/mod_deflate.html\">mod_deflate</a>.</p><p>Il y a des probl\u00e8mes connus avec les navigateurs et les proxies qui peuvent causer une incoh\u00e9rence entre ce que le navigateur attend et ce qu&rsquo;il re\u00e7oit en contenu compress\u00e9. Heureusement, ces cas diminuent en m\u00eame temps que les navigateurs les plus anciens. Les modules Apache peuvent aider en ajoutant l&rsquo;en-t\u00eate de r\u00e9ponse Vary automatiquement.</p><p>Les serveurs d\u00e9cident quoi gzipper en se basant sur le type de fichier, mais ils sont g\u00e9n\u00e9ralement trop restreints dans ce qu&rsquo;ils d\u00e9cident de compresser. La plupart des sites web gzip leurs documents HTML. Il est \u00e9galement int\u00e9ressant de gzipper vos scripts et les feuilles de style, ce que ne font pas de nombreux sites Web. En fait, il est int\u00e9ressant de compresser toute r\u00e9ponse de texte, y compris XML et JSON. Les images et les fichiers PDF ne doivent pas \u00eatre compress\u00e9s au format gzip, car ils le sont d\u00e9j\u00e0 par d&rsquo;autres moyens. Essayer de les gzipper entra\u00eene non seulement un gaspillage de CPU mais peut potentiellement augmenter la taille des fichiers r\u00e9sultants.</p><p>Gzipper autant que possible les fichiers est un moyen facile de r\u00e9duire le poids de la page et d&rsquo;acc\u00e9l\u00e9rer l&rsquo;exp\u00e9rience utilisateur.</p>", "id": "ycompress", "title": "Compresser avec Gzip les composants"}, {"content": "<p>La r\u00e9partition des composant permet de maximiser le nombre de t\u00e9l\u00e9chargements parall\u00e8les. Assurez-vous de ne pas utiliser plus de 2-4 domaines en raison du co\u00fbt de recherche DNS. Par exemple, vous pouvez h\u00e9berger votre code HTML et du contenu dynamique sur <code>www.example.org</code> et r\u00e9partir les composants statiques entre <code>static1.example.org</code> et <code>static2.example.org</code>.</p><p>Visitez &ldquo;<a href=\"http://yuiblog.com/blog/2007/04/11/performance-research-part-4/\">Maximizing Parallel Downloads in the Carpool Lane</a>&rdquo; de Tenni Theurer et Patty Chi pour plus d&rsquo;informations.</p>", "id": "ysplit", "title": "R\u00e9partir les composants sur plusieurs domaines"}, {"content": "<p>Le probl\u00e8me des scripts est qu&rsquo;ils bloquent les t\u00e9l\u00e9chargements en parall\u00e8le. La <a href=\"http://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html#sec8.1.4\">sp\u00e9cification HTTP/1.1</a> sugg\u00e8re que les navigateurs ne t\u00e9l\u00e9chargent pas plus de deux composants en parall\u00e8le par nom d&rsquo;h\u00f4te. Si vous servez vos images \u00e0 partir de plusieurs noms d&rsquo;h\u00f4tes, vous pouvez obtenir plus de deux t\u00e9l\u00e9chargements en parall\u00e8le. Cependant, pendant le t\u00e9l\u00e9chargement d&rsquo;un script, le navigateur ne d\u00e9marre pas d&rsquo;autres t\u00e9l\u00e9chargements y compris sur diff\u00e9rents noms de domaine.</p><p>Dans certaines situations, il n&rsquo;est pas facile de d\u00e9placer ses scripts en bas de page. Si, par exemple, le script utilise <code>document.write</code> pour ins\u00e9rer une partie du contenu de la page, il ne peut pas \u00eatre d\u00e9plac\u00e9 plus bas dans la page. Il pourrait s&rsquo;ensuivre des probl\u00e8mes de visibilit\u00e9. Dans de nombreux cas, il existe des moyens de contourner ces situations.</p><p>Une autre suggestion qui revient souvent est l&rsquo;utilisation de scripts diff\u00e9r\u00e9s. L&rsquo;attribut <code>DEFER</code> indique que le script ne contient pas document.write. C&rsquo;est une indication pour les navigateurs qu&rsquo;ils peuvent continuer le rendu de la page. Malheureusement, Firefox ne prend pas en charge l&rsquo;attribut <code>DEFER</code>. Dans Internet Explorer, le script peut \u00eatre diff\u00e9r\u00e9 mais pas autant que vous le souhaitez. Si un script peut \u00eatre diff\u00e9r\u00e9, il peut \u00e9galement \u00eatre d\u00e9plac\u00e9 vers le bas de la page. Cela rendra vos pages Web plus rapides \u00e0 charger.</p>", "id": "yjsbottom", "title": "Mettres les scripts en bas de page"}, {"content": "<p>Il ya deux aspects \u00e0 cette r\u00e8gle :</p><ul><li>Pour les composants statiques : mettre en \u0153uvre une politique du \u00abn&rsquo;expire jamais\u00bb par l&rsquo;utilisation d&rsquo;en-t\u00eates Expire fix\u00e9s loin dans le futur.</li><li>Pour les composants dynamiques : utiliser un en-t\u00eate Cache-Control appropri\u00e9 pour aider le navigateur avec les requ\u00eates conditionnelles.</li></ul><p>Le design des pages web est de plus en plus riche, ce qui signifie plus de scripts, plus de feuilles de style, plus d&rsquo;images et de Flash dans la page. Un nouveau visiteur de votre page peut avoir \u00e0 faire plusieurs requ\u00eates HTTP, mais en utilisant l&rsquo;en-t\u00eate Expire, vous rendez ces composants cachables. Cela \u00e9vite les requ\u00eates HTTP inutiles sur les pages vues ult\u00e9rieurement. Les en-t\u00eates Expire sont le plus souvent utilis\u00e9s avec des images, mais ils doivent \u00eatre utilis\u00e9s sur tous les composants, y compris les scripts, les feuilles de style et les composants Flash.</p><p>Les navigateurs (et les proxies) utilisent un cache afin de r\u00e9duire le nombre et la taille des requ\u00eates HTTP, ce qui acc\u00e9l\u00e8re le chargement des pages. Un serveur web utilise l&rsquo;en-t\u00eate Expire dans la r\u00e9ponse HTTP pour indiquer au client combien de temps un composant peut \u00eatre mis en cache. Une date lointaine dans l&rsquo;en-t\u00eate Expire indique au navigateur que cette r\u00e9ponse reste valide jusqu&rsquo;au 15 Avril 2015.</p><pre><code>Expires: Thu, 15 Apr 2015 20:00:00 GMT</code></pre><p>Si votre serveur est Apache, utilisez la directive ExpiresDefault qui permet de fixer une date d&rsquo;expiration par rapport \u00e0 la date actuelle. Cet exemple de directive ExpiresDefault fixe la date d&rsquo;expiration dans 10 ans \u00e0 partir du moment de la demande.</p><pre><code>ExpiresDefault &quot;access plus 10 years&quot;</code></pre><p>Gardez \u00e0 l&rsquo;esprit, si vous utilisez un en-t\u00eate Expire loin dans le futur que vous devrez changer le nom de fichier du composant \u00e0 chaque fois que celui-ci est modifi\u00e9. Chez Yahoo!, un num\u00e9ro de version est int\u00e9gr\u00e9 dans le nom de fichier du composant, par exemple yahoo_2.0.6.js.</p><p>Utiliser un en-t\u00eate Expire loin dans le futur affecte uniquement les pages vues d&rsquo;un utilisateur revenant sur votre site. Cela n&rsquo;a aucun effet sur \u200b\u200ble nombre de requ\u00eates HTTP n\u00e9cessaires quand un utilisateur visite votre site pour la premi\u00e8re fois et que la m\u00e9moire cache du navigateur est vide. Par cons\u00e9quent, l&rsquo; impact de cette am\u00e9lioration de la performance d\u00e9pend de la fr\u00e9quence d&rsquo;utilisateurs r\u00e9guliers. Ceux-ci poss\u00e8dent en effet un cache amorc\u00e9. (Un \u00abcache amorc\u00e9\u00bb contient d\u00e9j\u00e0 tous les \u00e9l\u00e9ments de la page.) Nous <a href=\"http://yuiblog.com/blog/2007/01/04/performance-research-part-2/\">avons mesur\u00e9 ceci chez Yahoo!</a> et trouv\u00e9 que le nombre de pages vues avec un cache amorc\u00e9 est de 75 \u00e0 85 %. En utilisant un en-t\u00eate Expire loin dans le futur, vous augmentez le nombre de composants qui sont mis en cache par le navigateur et re-utilis\u00e9s sur les vues ult\u00e9rieures de pages sans envoyer un seul octet sur \u200b\u200bla connexion Internet de l&rsquo;utilisateur.</p>", "id": "yexpires", "title": "Ajouter des en-t\u00eates Expires ou Cache-Control"}, {"content": "<p>Rassembler les composants dans un document multi-parties (comme un e-mail avec des pi\u00e8ces jointes), permet de r\u00e9cup\u00e9rer plusieurs composants en une seule requ\u00eate HTTP (souvenez-vous : les requ\u00eates HTTP sont co\u00fbteuses). Lorsque vous utilisez cette technique, v\u00e9rifiez d&rsquo;abord si le terminal utilisateur la prend en charge (Ceci ne fonctionne pas sur iPhone).</p>", "id": "ymultipart", "title": "Rassembler les composants en un document multi-parties"}, {"content": "<p>L&rsquo;\u00e9quipe de <a href=\"http://mail.yahoo.com\">Yahoo! Mail</a> a constat\u00e9 que lors de l&rsquo;utilisation de <code>XMLHttpRequest</code>, POST est mis en \u0153uvre dans les navigateurs comme un processus en deux \u00e9tapes : l&rsquo;envoi des en-t\u00eates puis l&rsquo;envoi de donn\u00e9es. Il est donc pr\u00e9f\u00e9rable d&rsquo;utiliser GET, qui ne prend qu&rsquo;un paquet TCP pour envoyer (sauf si vous avez un grand nombre de cookies). La longueur maximale pour une URL dans IE est 2K, donc si vous envoyez des donn\u00e9es de plus de 2K vous pourriez ne pas \u00eatre en mesure d&rsquo;utiliser GET.</p><p>Un c\u00f4t\u00e9 int\u00e9ressant est que POST sans affichage r\u00e9el de donn\u00e9es se comporte comme GET. Sur la base des sp\u00e9cifications <a href=\"http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html\">HTTP</a>, GET est destin\u00e9 \u00e0 r\u00e9cup\u00e9rer des informations. Il serait donc tr\u00e8s judicieux (s\u00e9mantiquement) d&rsquo;utiliser GET lorsque vous r\u00e9cup\u00e9rez des donn\u00e9es, par opposition \u00e0 l&rsquo;envoi de donn\u00e9es \u00e0 stocker c\u00f4t\u00e9 serveur.</p>", "id": "yxhrmethod", "title": "Utiliser GET pour les requ\u00eates Ajax"}, {"content": "<p>80% du temps de r\u00e9ponse de l&rsquo;utilisateur final est pass\u00e9 sur le front-end. La majeure partie de ce temps est consacr\u00e9e au t\u00e9l\u00e9chargement de tous les composants de la page : images, feuilles de style, scripts, flash, etc. R\u00e9duire le nombre de composants r\u00e9duit le nombre de requ\u00eates HTTP n\u00e9cessaires pour rendre la page. C&rsquo;est la cl\u00e9 de pages plus rapides.</p><p>Une fa\u00e7on de r\u00e9duire le nombre de composants dans la page est de simplifier la conception de la page. Mais existe-t-il un moyen de cr\u00e9er des pages avec un contenu plus riche tout en conservant des temps de r\u00e9ponse rapides ? Voici quelques techniques pour r\u00e9duire le nombre de requ\u00eates HTTP, tout en conservant des pages riches d&rsquo;un point de vue design.</p><p>Les <strong>fichiers concat\u00e9n\u00e9s</strong> sont un moyen de r\u00e9duire le nombre de requ\u00eates HTTP en combinant tous les scripts et toutes les CSS dans une feuille de style unique et en un seul script. la concat\u00e9nation de fichiers est plus difficile lorsque les scripts et les feuilles de style varient d&rsquo;une page \u00e0 l&rsquo;autre. Inclure ceci dans votre processus de construction des pages am\u00e9liore les temps de r\u00e9ponse.</p><p>L&rsquo;utilisation des <a href=\"http://alistapart.com/articles/sprites\"><strong>sprites CSS</strong></a> est la meilleure m\u00e9thode pour r\u00e9duire le nombre de demandes d&rsquo;images. Combinez vos images de fond en une seule image et utilisez les propri\u00e9t\u00e9s CSS <code>background-image</code> et <code>background-position</code> pour afficher le segment de l&rsquo;image souhait\u00e9e.</p><p>Les <a href=\"http://www.w3.org/TR/html401/struct/objects.html#h-13.6\"><strong>cartes-image</strong></a> combinent plusieurs images en une seule image. La taille globale est \u00e0 peu pr\u00e8s la m\u00eame, mais la r\u00e9duction du nombre de requ\u00eates HTTP acc\u00e9l\u00e8re le chargement de la page. Les cartes-images ne fonctionnent que si les images sont contigu\u00eb dans la page, comme un menu de navigation. D\u00e9finir les coordonn\u00e9es de chaque segment dans une carte d&rsquo;image peut \u00eatre fastidieux et source d&rsquo;erreurs. L&rsquo;utilisation de cartes-images pour la navigation casse l&rsquo;accessibilit\u00e9 de la page, donc non recommand\u00e9.</p><p>Les <strong>images en ligne</strong> utilisent le <a href=\"http://tools.ietf.org/html/rfc2397\"><code>data:</code> URL scheme</a> pour int\u00e9grer les donn\u00e9es d&rsquo;image dans la page en cours. Cela peut augmenter la taille de votre document HTML. Combiner des images en ligne dans vos feuilles de style (en cache) est un moyen de r\u00e9duire les requ\u00eates HTTP et \u00e9viter d&rsquo;augmenter la taille de vos pages. Les images en ligne ne sont pas encore prise en charge dans tous les navigateurs principaux.</p><p>R\u00e9duire le nombre de requ\u00eates HTTP de votre page est un point de d\u00e9part id\u00e9al. C&rsquo;est la recommandation qui permet d&rsquo;am\u00e9liorer les performances pour les nouveaux visiteurs de mani\u00e8re la plus significative. Comme d\u00e9crit dans le billet de blog de Tenni Theurer <a href=\"http://yuiblog.com/blog/2007/01/04/performance-research-part-2/\">Browser Cache Usage - Exposed!</a>, 40 \u00e0 60% des visiteurs quotidiens de votre site le consultent avec un cache navigateur vide. Am\u00e9liorer le temps de chargement pour ces nouveaux visiteurs est la cl\u00e9 d&rsquo;une meilleure exp\u00e9rience utilisateur.</p>", "id": "ynumreq", "title": "R\u00e9duire le nombre de requ\u00eates HTTP"}, {"content": "<p>L&rsquo;acc\u00e8s aux \u00e9l\u00e9ments du DOM avec JavaScript est lent. Afin d&rsquo;avoir une page plus r\u00e9active, vous devez :</p><ul><li>Mettre en cache les r\u00e9f\u00e9rences \u00e0 des \u00e9l\u00e9ments accessibles.</li><li>Mettre \u00e0 jour les n\u0153uds \u00abhors ligne\u00bb et les ajouter ensuite \u00e0 l&rsquo;arbre.</li><li>\u00c9viter de corriger la mise en page avec JavaScript.</li></ul><p>Consultez le YUI theatre&rsquo;s <a href=\"http://yuiblog.com/blog/2007/12/20/video-lecomte/\">&ldquo;High Performance Ajax Applications&rdquo;</a> de Julien Lecomte pour plus d&rsquo;informations.</p>", "id": "ydom_access", "title": "Minimiser les acc\u00e8s DOM"}, {"content": "<p>Ne pas utiliser une image plus grande que votre besoin sous pr\u00e9texte de pouvoir d\u00e9finir la largeur et la hauteur en HTML. Si vous avez besoin <code>&lt;img width=&quot;100&quot; height=&quot;100&quot; src=&quot;mycat.jpg&quot; alt=&quot;My Cat&quot; /&gt;</code> alors votre image (Mycat.jpg) devrait faire 100x100px plut\u00f4t qu&rsquo;utiliser une image de 500x500px r\u00e9duite.</p>", "id": "yimgnoscale", "title": "Ne pas mettre \u00e0 l\u2019\u00e9chelle les images en HTML"}, {"content": "<p>Le filtre propri\u00e9taire IE <code>AlphaImageLoader</code> vise \u00e0 r\u00e9gler un probl\u00e8me de couleurs vraies semi-transparentes dans les versions IE &lt; 7. Le probl\u00e8me avec ce filtre est qu&rsquo;il bloque le rendu. Le navigateur se bloque lorsque l&rsquo;image est en cours de t\u00e9l\u00e9chargement. Il augmente \u00e9galement la consommation de m\u00e9moire et est appliqu\u00e9 par \u00e9l\u00e9ment, et non par image, de sorte que le probl\u00e8me est multipli\u00e9.</p><p>La meilleure approche est d&rsquo;\u00e9viter compl\u00e8tement <code>AlphaImageLoader</code> et d&rsquo;utiliser une version d\u00e9grad\u00e9e PNG8 \u00e0 la place dans IE. Si vous avez absolument besoin du filtre <code>AlphaImageLoader</code>, utilisez le vieux hack <code>_filter</code> afin de ne pas p\u00e9naliser vos utilisateurs IE7+.</p>", "id": "ynofilter", "title": "\u00c9viter les filtres"}, {"content": "<p>Le favicon.ico est une image qui r\u00e9side \u00e0 la racine de votre serveur. C&rsquo;est un mal n\u00e9cessaire parce que m\u00eame si vous ne vous en souciez pas, un navigateur saura toujours le demander. Il est donc pr\u00e9f\u00e9rable de ne pas r\u00e9pondre avec un <code>404 Not Found</code>. En outre, puisqu&rsquo;il est sur \u200b\u200ble m\u00eame serveur, des cookies sont envoy\u00e9s chaque fois qu&rsquo;il est demand\u00e9. Cette image interf\u00e8re \u00e9galement avec la s\u00e9quence de t\u00e9l\u00e9chargement. Par exemple dans IE, lorsque vous demandez des composants suppl\u00e9mentaires dans le onload, le favicon sera t\u00e9l\u00e9charg\u00e9 avant ces composants suppl\u00e9mentaires.</p><p>Donc, pour pallier les inconv\u00e9nients d&rsquo;avoir un favicon.ico, assurez-vous de :</p><ul><li>Le faire petit, de pr\u00e9f\u00e9rence moins d&rsquo;1KB.</li><li>R\u00e9gler l&rsquo;en-t\u00eate Expire de fa\u00e7on judicieuse pour vous (puisque vous ne pourrez pas le renommer si vous d\u00e9cidez de le changer). Vous pouvez probablement r\u00e9gler l&rsquo;en-t\u00eate Expires quelques mois dans le futur. V\u00e9rifier la derni\u00e8re date de modification de votre favicon.ico actuelle peut aider \u00e0 faire un choix \u00e9clair\u00e9.</li></ul><p><a href=\"http://www.imagemagick.org\">ImageMagick</a> peut vous aider \u00e0 cr\u00e9er de petits favicons.</p>", "id": "yfavicon", "title": "Faire un petit favicon.ico et le rendre cachable"}, {"content": "<p>La proximit\u00e9 de l&rsquo;utilisateur par rapport \u00e0 votre serveur web a un impact sur les temps de r\u00e9ponse. Le d\u00e9ploiement de votre contenu sur plusieurs serveurs g\u00e9ographiquement dispers\u00e9s rendra vos pages plus rapides du point de vue de l&rsquo;utilisateur. Mais par o\u00f9 commencer ?</p><p>Dans un premier temps, ne tentez pas la refonte de votre application web pour travailler en mode distribu\u00e9 afin de mettre en \u0153uvre du contenu dispers\u00e9 g\u00e9ographiquement. Selon l&rsquo;application, l&rsquo;\u00e9volution de l&rsquo;architecture pourrait inclure des t\u00e2ches redoutables telles que la synchronisation d&rsquo;\u00e9tats \u200b\u200bde session et la r\u00e9plication de transactions de base de donn\u00e9es de serveurs \u00e0 serveurs r\u00e9partis g\u00e9ographiquement. Vous pourriez \u00eatre retard\u00e9s, voire ne jamais atteindre l&rsquo;objectif visant \u00e0 r\u00e9duire la distance entre les utilisateurs et le contenu si vous souhaitez passer par cette \u00e9tape d&rsquo;am\u00e9lioration d&rsquo;architecture applicative.</p><p>Rappelez-vous que 80 \u00e0 90% du temps de r\u00e9ponse de l&rsquo;utilisateur final est pass\u00e9 \u00e0 t\u00e9l\u00e9charger tous les composants de la page : images, feuilles de style, scripts, flash, etc. C&rsquo;est la <em>r\u00e8gle d&rsquo;or de la performance</em>. Plut\u00f4t que de partir sur la refonte de votre architecture applicative, il vaut mieux d&rsquo;abord r\u00e9partir votre contenu statique. Non seulement il permet une plus grande r\u00e9duction des temps de r\u00e9ponse, mais il est de plus facile \u00e0 mettre en \u0153uvre gr\u00e2ce \u00e0 des r\u00e9seaux de diffusion de contenu.</p><p>Un r\u00e9seau de diffusion de contenu (CDN) est un ensemble de serveurs Web r\u00e9partis sur plusieurs endroits g\u00e9ographiques pour fournir un contenu de fa\u00e7on plus efficace aux utilisateurs. Le serveur s\u00e9lectionn\u00e9 pour fournir du contenu \u00e0 un utilisateur sp\u00e9cifique est g\u00e9n\u00e9ralement bas\u00e9 sur une mesure de proximit\u00e9 de r\u00e9seau. Par exemple, le serveur avec le moins de sauts de r\u00e9seau ou le serveur avec le meilleur temps de r\u00e9ponse est choisi.</p><p>Certaines grandes entreprises de l&rsquo;Internet poss\u00e8dent leur propre CDN, mais il peut \u00eatre moins cher d&rsquo;utiliser un fournisseur de services CDN, comme <a href=\"http://www.akamai.com/\">Akamai Technologies</a>, <a href=\"http://www.edgecast.com/\">EdgeCast</a> ou <a href=\"http://www.level3.com/index.cfm?pageID=36\">level3</a>. Pour les entreprises qui d\u00e9marrent et les sites web priv\u00e9s, le co\u00fbt d&rsquo;un service CDN peut \u00eatre prohibitif. Mais que votre public cible grandisse et devienne plus global, et alors un CDN est n\u00e9cessaire pour obtenir des temps de r\u00e9ponse rapides. Chez Yahoo!, ceux qui ont d\u00e9plac\u00e9 le contenu statique de leurs serveurs d&rsquo;applications Web \u00e0 un CDN (\u00e0 la fois chez des prestataires externes comme ceux mentionn\u00e9s ci-dessus et leur propre <a href=\"https://cwiki.apache.org/TS/traffic-server.html\">CDN</a> chez Yahoo) am\u00e9liorent le temps de r\u00e9ponse de l&rsquo;utilisateur final de 20% ou plus. Le passage \u00e0 un CDN est un changement de code relativement facile qui va consid\u00e9rablement am\u00e9liorer la vitesse de votre site web.</p>", "id": "ycdn", "title": "Utiliser un r\u00e9seau de diffusion de contenu (CDN)"}, {"content": "<p>Les redirections sont effectu\u00e9es en utilisant les codes d&rsquo;\u00e9tat 301 et 302 . Voici un exemple d&rsquo;en-t\u00eates HTTP contenus dans une r\u00e9ponse 301 :</p><pre><code>HTTP/1.1 301 Moved PermanentlyLocation: http://example.com/newuriContent-Type: text/html</code></pre><p>Le navigateur conduit automatiquement l&rsquo;utilisateur vers l&rsquo;URL sp\u00e9cifi\u00e9e dans le champ <code>Location</code>. Toutes les informations n\u00e9cessaires pour une redirection sont contenues dans les en-t\u00eates. Le corps de la r\u00e9ponse est g\u00e9n\u00e9ralement vide. Malgr\u00e9 leur nom, aucune r\u00e9ponse 301 ou 302 n&rsquo;est mise en cache dans la pratique, sauf si des en-t\u00eates suppl\u00e9mentaires, comme <code>Expire</code> ou <code>Cache-Control</code> indiquent qu&rsquo;elle devrait l&rsquo;\u00eatre. La balise meta refresh et JavaScript sont d&rsquo;autres fa\u00e7ons de diriger les utilisateurs vers une URL diff\u00e9rente, mais si vous devez faire une redirection, la technique pr\u00e9f\u00e9r\u00e9e est d&rsquo;utiliser les codes d&rsquo;\u00e9tat HTTP 3xx standards, principalement pour s&rsquo;assurer que le bouton de retour du navigateur fonctionne correctement.</p><p>La principale chose \u00e0 retenir est que les redirections ralentissent l&rsquo;exp\u00e9rience utilisateur. L&rsquo;insertion d&rsquo;une redirection entre l&rsquo;utilisateur et le document HTML retarde tout le rendu de la page puisqu&rsquo;aucun composant ne peut commencer \u00e0 \u00eatre t\u00e9l\u00e9charg\u00e9 jusqu&rsquo;\u00e0 ce que le document HTML ne soit arriv\u00e9.</p><p>L&rsquo;une des redirections les plus inutiles est aussi l&rsquo;une des plus fr\u00e9quentes (et les d\u00e9veloppeurs web ne sont g\u00e9n\u00e9ralement pas au courant). Elle se produit quand une barre oblique (/) est absente depuis une URL qui devrait en avoir une. Par exemple, aller \u00e0 <a href=\"http://astrology.yahoo.com/astrology entra\u00eene une r\u00e9ponse 301 contenant une redirection vers [http://astrology.yahoo.com / astrologie/](http://astrology.yahoo.com/astrology/\">http://astrology.yahoo.com/astrology</a> (notez le slash ajout\u00e9). Ce probl\u00e8me est r\u00e9solu dans Apache en utilisant les directives <code>Alias</code>, <code>mod_rewrite</code> ou <code>DirectorySlash directive</code>.</p><p>La connexion d&rsquo;un ancien site Web vers un nouveau est un autre usage r\u00e9pandu pour les redirections. D&rsquo;autres usages consistent \u00e0 relier les diff\u00e9rentes parties d&rsquo;un site Web et de diriger l&rsquo;utilisateur en fonction de certaines conditions (type de navigateur, type de compte utilisateur, etc.). Utiliser une redirection pour connecter deux sites Web est simple et n\u00e9cessite peu de code suppl\u00e9mentaire. Bien que l&rsquo;utilisation des redirections dans ces situations r\u00e9duit la complexit\u00e9 pour les d\u00e9veloppeurs, elle d\u00e9grade l&rsquo;exp\u00e9rience utilisateur. Si la redirection a lieu sur le m\u00eame serveur, il est possible d&rsquo;utiliser <code>Alias\u200b\u200b</code> et <code>mod_rewrite</code> comme alternatives pour cette utilisation de redirections. Si un changement de nom de domaine est la cause de l&rsquo;utilisation de redirections, une alternative est de cr\u00e9er un CNAME (un enregistrement DNS qui cr\u00e9e un pointage d&rsquo;alias de nom d&rsquo;un domaine \u00e0 l&rsquo;autre) en combinaison avec <code>Alias</code> ou <code>mod_rewrite</code>.</p>", "id": "yredirects", "title": "\u00c9viter les redirections"}, {"content": "<p>La minification consiste \u00e0 enlever des caract\u00e8res inutiles \u00e0 partir du code afin de r\u00e9duire sa taille; ce qui am\u00e9liore les temps de chargement. Lorsque le code est minifi\u00e9, tous les commentaires sont supprim\u00e9s ainsi que les caract\u00e8res inutiles ou blancs (espaces, sauts de ligne, tabulations). Dans le cas du langage JavaScript, ceci am\u00e9liore les performances de temps de r\u00e9ponse en raison de la taille du fichier t\u00e9l\u00e9charg\u00e9 plus r\u00e9duite. Deux outils populaires pour minifier le code JavaScript sont <a href=\"http://crockford.com/javascript/jsmin\">JSMin</a> et <a href=\"http://developer.yahoo.com/yui/compressor/\">YUI Compressor</a>. Le compresseur YUI PEUT aussi minifier les CSS.</p><p>L&rsquo;obfuscation est une alternative qui peut \u00eatre appliqu\u00e9e au code source. Plus complexe que la minification et donc plus susceptible de g\u00e9n\u00e9rer des bugs \u00e0 la suite de l&rsquo;\u00e9tape de brouillage proprement dite. Dans une enqu\u00eate sur dix sites web am\u00e9ricains, la minification permet une r\u00e9duction de taille de 21% contre 25% pour l&rsquo;obfuscation. Bien que l&rsquo;obfuscation ait une r\u00e9duction de taille sup\u00e9rieure, il reste moins risqu\u00e9 de minifier le JavaScript.</p><p>En plus de minifier les scripts externes et les feuilles de style, les blocs en ligne <code>&lt;script&gt;</code> et <code>&lt;style&gt;</code> peuvent et doivent \u00e9galement \u00eatre minifi\u00e9s. M\u00eame si vous gzippez les scripts et les styles, les minifier en plus permet encore de r\u00e9duire la taille de 5% ou plus. Vu que l&rsquo;utilisation et la taille de code JavaScript et de feuilles de style CSS augmente, les \u00e9conomies r\u00e9alis\u00e9es par minification du code sont plus grandes.</p>", "id": "yminify", "title": "Minimifier JavaScript et CSS"}], "en": [{"content": "<p>Image with empty string <strong>src</strong> attribute occurs more than one will expect. It appears in two form:</p><ol><li>straight HTML</li></ol><pre><code>&lt;img src=&quot;&quot;&gt;</code></pre><ol><li>JavaScript</li></ol><pre><code>var img = new Image();img.src = &quot;&quot;;</code></pre><p>Both forms cause the same effect: browser makes another request to your server.</p><ul><li><strong>Internet Explorer</strong> makes a request to the directory in which the page is located.</li><li><strong>Safari and Chrome</strong> make a request to the actual page itself.</li><li><strong>Firefox</strong> 3 and earlier versions behave the same as Safari and Chrome, but version 3.5 addressed this issue <a href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=444931\">[bug 444931]</a> and no longer sends a request.</li><li><strong>Opera</strong> does not do anything when an empty image src is encountered.</li></ul><p><strong>Why is this behavior bad?</strong></p><ol><li>Cripple your servers by sending a large amount of unexpected traffic, especially for pages that get millions of page views per day.</li><li>Waste server computing cycles generating a page that will never be viewed.</li><li>Possibly corrupt user data. If you are tracking state in the request, either by cookies or in another way, you have the possibility of destroying data. Even though the image request does not return an image, all of the headers are read and accepted by the browser, including all cookies. While the rest of the response is thrown away, the damage may already be done.</li></ol><p>The root cause of this behavior is the way that URI resolution is performed in browsers. This behavior is defined in RFC 3986 - Uniform Resource Identifiers. When an empty string is encountered as a URI, it is considered a relative URI and is resolved according to the algorithm defined in section 5.2. This specific example, an empty string, is listed in section 5.4. Firefox, Safari, and Chrome are all resolving an empty string correctly per the specification, while Internet Explorer is resolving it incorrectly, apparently in line with an earlier version of the specification, RFC 2396 - Uniform Resource Identifiers (this was obsoleted by RFC 3986). So technically, the browsers are doing what they are supposed to do to resolve relative URIs. The problem is that in this context, the empty string is clearly unintentional.</p><p>HTML5 adds to the description of the tag&rsquo;s src attribute to instruct browsers not to make an additional request in section 4.8.2:</p><blockquote><p>The src attribute must be present, and must contain a valid URL referencing a non-interactive, optionally animated, image resource that is neither paged nor scripted. If the base URI of the element is the same as the document&rsquo;s address, then the src attribute&rsquo;s value must not be the empty string.</p></blockquote><p>Hopefully, browsers will not have this problem in the future. Unfortunately, there is no such clause for <code>&lt;script src=&quot;&quot;&gt;</code> and <code>&lt;link href=&quot;&quot;&gt;</code>. Maybe there is still time to make that adjustment to ensure browsers don&rsquo;t accidentally implement this behavior.</p><p>This rule was inspired by Yahoo!&rsquo;s JavaScript guru Nicolas C. Zakas. For more information check out his article &ldquo;<a href=\"http://www.nczonline.net/blog/2009/11/30/empty-image-src-can-destroy-your-site/\">Empty image src can destroy your site</a>&rdquo;.</p>", "id": "yemptysrc", "title": "Avoid Empty Image src"}, {"content": "<p>Sometimes pages feel less responsive because of too many event handlers  attached to different elements of the DOM tree which are then executed  too often. That&rsquo;s why using <em>event delegation</em> is a good approach. If  you have 10 buttons inside a <code>div</code>, attach only one event handler to the  div wrapper, instead of one handler for each button. Events bubble up so  you&rsquo;ll be able to catch the event and figure out which button it  originated from.</p><p>You also don&rsquo;t need to wait for the onload event in order to start doing  something with the DOM tree. Often all you need is the element you want  to access to be available in the tree. You don&rsquo;t have to wait for all  images to be downloaded. <code>DOMContentLoaded</code> is the event you might  consider using instead of onload, but until it&rsquo;s available in all  browsers, you can use the <a href=\"http://developer.yahoo.com/yui/event/\">YUI  Event</a> utility, which has an  <code>onAvailable</code> method.</p><p>For more information check the YUI theatre&rsquo;s <a href=\"http://yuiblog.com/blog/2007/12/20/video-lecomte/\">&ldquo;High Performance Ajax  Applications&rdquo;</a> by  Julien Lecomte.</p>", "id": "yevents", "title": "Develop Smart Event Handlers"}, {"content": "<p>HTTP requests are expensive so making an HTTP request and getting a useless response (i.e. 404 Not Found) is totally unnecessary and will slow down the user experience without any benefit.</p><p>Some sites have helpful 404s &ldquo;Did you mean X?&rdquo;, which is great for the user experience but also wastes server resources (like database, etc). Particularly bad is when the link to an external JavaScript is wrong and the result is a 404. First, this download will block parallel downloads. Next the browser may try to parse the 404 response body as if it were JavaScript code, trying to find something usable in it.</p>", "id": "yno404", "title": "Avoid 404s"}, {"content": "<p>The Domain Name System (DNS) maps hostnames to IP addresses, just as phonebooks map people&rsquo;s names to their phone numbers. When you type www.yahoo.com into your browser, a DNS resolver contacted by the browser returns that server&rsquo;s IP address. DNS has a cost. It typically takes 20-120 milliseconds for DNS to lookup the IP address for a given hostname. The browser can&rsquo;t download anything from this hostname until the DNS lookup is completed.</p><p>DNS lookups are cached for better performance. This caching can occur on a special caching server, maintained by the user&rsquo;s ISP or local area network, but there is also caching that occurs on the individual user&rsquo;s computer. The DNS information remains in the operating system&rsquo;s DNS cache (the &ldquo;DNS Client service&rdquo; on Microsoft Windows). Most browsers have their own caches, separate from the operating system&rsquo;s cache. As long as the browser keeps a DNS record in its own cache, it doesn&rsquo;t bother the operating system with a request for the record.</p><p>Internet Explorer caches DNS lookups for 30 minutes by default, as specified by the <code>DnsCacheTimeout</code> registry setting. Firefox caches DNS lookups for 1 minute, controlled by the <code>network.dnsCacheExpiration</code> configuration setting. (Fasterfox changes this to 1 hour.)</p><p>When the client&rsquo;s DNS cache is empty (for both the browser and the operating system), the number of DNS lookups is equal to the number of unique hostnames in the web page. This includes the hostnames used in the page&rsquo;s URL, images, script files, stylesheets, Flash objects, etc. Reducing the number of unique hostnames reduces the number of DNS lookups.</p><p>Reducing the number of unique hostnames has the potential to reduce the amount of parallel downloading that takes place in the page. Avoiding DNS lookups cuts response times, but reducing parallel downloads may increase response times. My guideline is to split these components across at least two but no more than four hostnames. This results in a good compromise between reducing DNS lookups and allowing a high degree of parallel downloads.</p>", "id": "ydns", "title": "Reduce DNS lookups"}, {"content": "<p>Redirects are accomplished using the 301 and 302 status codes. Here&rsquo;s an example of the HTTP headers in a 301 response:</p><pre><code>HTTP/1.1 301 Moved PermanentlyLocation: http://example.com/newuriContent-Type: text/html</code></pre><p>You can take a closer look at your page and ask yourself: &ldquo;What&rsquo;s absolutely required in order to render the page initially?&rdquo;. The rest of the content and components can wait.</p><p>JavaScript is an ideal candidate for splitting before and after the onload event. For example if you have JavaScript code and libraries that do drag and drop and animations, those can wait, because dragging elements on the page comes after the initial rendering. Other places to look for candidates for post-loading include hidden content (content that appears after a user action) and images below the fold.</p><p>Tools to help you out in your effort: <a href=\"http://developer.yahoo.com/yui/imageloader/\">YUI Image Loader</a> allows you to delay images below the fold and the <a href=\"http://developer.yahoo.com/yui/get/\">YUI Get utility</a> is an easy way to include JS and CSS on the fly. For an example in the wild take a look at <a href=\"http://www.yahoo.com\">Yahoo! Home Page</a> with Firebug&rsquo;s Net Panel turned on.</p><p>It&rsquo;s good when the performance goals are inline with other web development best practices. In this case, the idea of progressive enhancement tells us that JavaScript, when supported, can improve the user experience but you have to make sure the page works even without JavaScript. So after you&rsquo;ve made sure the page works fine, you can enhance it with some post-loaded scripts that give you more bells and whistles such as drag and drop and animations.</p>", "id": "ypostload", "title": "Postload Components"}, {"content": "<p>While researching performance at Yahoo!, we discovered that moving stylesheets to the document HEAD makes pages <em>appear</em> to be loading faster. This is because putting stylesheets in the HEAD allows the page to render progressively.</p><p>Front-end engineers that care about performance want a page to load progressively; that is, we want the browser to display whatever content it has as soon as possible. This is especially important for pages with a lot of content and for users on slower Internet connections. The importance of giving users visual feedback, such as progress indicators, has been well researched and <a href=\"http://www.useit.com/papers/responsetime.html\">documented</a>. In our case the HTML page is the progress indicator! When the browser loads the page progressively the header, the navigation bar, the logo at the top, etc. all serve as visual feedback for the user who is waiting for the page. This improves the overall user experience.</p><p>The problem with putting stylesheets near the bottom of the document is that it prohibits progressive rendering in many browsers, including Internet Explorer. These browsers block rendering to avoid having to redraw elements of the page if their styles change. The user is stuckviewing a blank white page.</p><p>The <a href=\"http://www.w3.org/TR/html4/struct/links.html#h-12.3\">HTML specification</a> clearly states that stylesheets are to be included in the HEAD of thepage: &ldquo;Unlike A, [LINK] may only appear in the HEAD section of adocument, although it may appear any number of times. &ldquo; Neither of the alternatives, the blank white screen or flash of unstyled content, are worth the risk. The optimal solution is to follow the HTML specification and load your stylesheets in the document HEAD.</p>", "id": "ycsstop", "title": "Put Stylesheets at Top"}, {"content": "<p>Preload may look like the opposite of post-load, but it actually has a different goal. By preloading components you can take advantage of the time the browser is idle and request components (like images, styles and scripts) you&rsquo;ll need in the future. This way when the user visits the next page, you could have most of the components already in the cache and your page will load much faster for the user.</p><p>There are actually several types of preloading:</p><ul><li><em>Unconditional</em> preload - as soon as onload fires, you go ahead and fetch some extra components. Check google.com for an example of how a sprite image is requested onload. This sprite image is not needed on the google.com homepage, but it is needed on the consecutive search result page.</li><li><em>Conditional</em> preload - based on a user action you make an educated guess where the user is headed next and preload accordingly. On <a href=\"http://search.yahoo.com\">search.yahoo.com</a> you can see how some extra components are requested after you start typing in the input box.</li><li><em>Anticipated</em> preload - preload in advance before launching a redesign. It often happens after a redesign that you hear: &ldquo;The new site is cool, but it&rsquo;s slower than before&rdquo;. Part of the problem could be that the users were visiting your old site with a full cache, but the new one is always an empty cache experience. You can mitigate this side effect by preloading some components before you even launched the redesign. Your old site can use the time the browser is idle and request images and scripts that will be used by the new site</li></ul>", "id": "ypreload", "title": "Preload Components"}, {"content": "<p>One of the previous best practices states that CSS should be at the top in order to allow for progressive rendering.</p><p>In IE <code>@import</code> behaves the same as using <code>&lt;link&gt;</code> at the bottom of the page, so it&rsquo;s best not to use it.</p>", "id": "ycsslink", "title": "Choose &lt;link&gt; Over @import"}, {"content": "<p>This restriction is related to the fact that iPhone won&rsquo;t cache components bigger than 25K. Note that this is the <em>uncompressed</em> size. This is where minification is important because gzip alone may not be sufficient.</p><p>For more information check &ldquo;<a href=\"http://yuiblog.com/blog/2008/02/06/iphone-cacheability/\">Performance Research, Part 5: iPhone Cacheability - Making it Stick</a>&rdquo; by Wayne Shea and Tenni Theurer.</p>", "id": "yunder25", "title": "Keep Components Under 25 KB"}, {"content": "<p>Entity tags (ETags) are a mechanism that web servers and browsers use to determine whether the component in the browser&rsquo;s cache matches the one on the origin server. (An &ldquo;entity&rdquo; is another word a &ldquo;component&rdquo;: images, scripts, stylesheets, etc.) ETags were added to provide a mechanism for validating entities that is more flexible than the last-modified date. An ETag is a string that uniquely identifies a specific version of a component. The only format constraints are that the string be quoted. The origin server specifies the component&rsquo;s ETag using the <code>ETag</code> response header.</p><pre><code>HTTP/1.1 200 OKLast-Modified: Tue, 12 Dec 2006 03:03:59 GMTETag: &quot;10c24bc-4ab-457e1c1f&quot;Content-Length: 12195~~Later, if the browser has to validate a component, it uses the `If-None-Match` header to pass the ETag back to the origin server. If the ETags match, a 304 status code is returned reducing the response by 12195 bytes for this example.</code></pre><p>GET /i/yahoo.gif HTTP/1.1Host: us.yimg.comIf-Modified-Since: Tue, 12 Dec 2006 03:03:59 GMTIf-None-Match: &ldquo;10c24bc-4ab-457e1c1f&rdquo;HTTP/1.1 304 Not Modified~~</p><p>The problem with ETags is that they typically are constructed using attributes that make them unique to a specific server hosting a site. ETags won&rsquo;t match when a browser gets the original component from one server and later tries to validate that component on a different server, a situation that is all too common on Web sites that use a cluster of servers to handle requests. By default, both Apache and IIS embed data in the ETag that dramatically reduces the odds of the validity test succeeding on web sites with multiple servers.</p><p>The ETag format for Apache 1.3 and 2.x is <code>inode-size-timestamp</code>. Although a given file may reside in the same directory across multiple servers, and have the same file size, permissions, timestamp, etc., its inode is different from one server to the next.</p><p>IIS 5.0 and 6.0 have a similar issue with ETags. The format for ETags on IIS is <code>Filetimestamp:ChangeNumber</code>. A <code>ChangeNumber</code> is a counter used to track configuration changes to IIS. It&rsquo;s unlikely that the <code>ChangeNumber</code> is the same across all IIS servers behind a web site.</p><p>The end result is ETags generated by Apache and IIS for the exact same component won&rsquo;t match from one server to another. If the ETags don&rsquo;t match, the user doesn&rsquo;t receive the small, fast 304 response that ETags were designed for; instead, they&rsquo;ll get a normal 200 response along with all the data for the component. If you host your web site on just one server, this isn&rsquo;t a problem. But if you have multiple servers hosting your web site, and you&rsquo;re using Apache or IIS with the default ETag configuration, your users are getting slower pages, your servers have a higher load, you&rsquo;re consuming greater bandwidth, and proxies aren&rsquo;t caching your content efficiently. Even if your components have a far future <code>Expires</code> header, a conditional GET request is still made whenever the user hits Reload or Refresh.</p><p>If you&rsquo;re not taking advantage of the flexible validation model that ETags provide, it&rsquo;s better to just remove the ETag altogether. The <code>Last-Modified</code> header validates based on the component&rsquo;s timestamp. And removing the ETag reduces the size of the HTTP headers in both the response and subsequent requests. This <a href=\"http://support.microsoft.com/?id=922733\">Microsoft Support article</a> describes how to remove ETags. In Apache, this is done by simply adding the following line to your Apache configuration file:</p><pre><code> FileETag none</code></pre>", "id": "yetags", "title": "Configure ETags"}, {"content": "<p>It hurts performance to include the same JavaScript file twice in one page. This isn&rsquo;t as unusual as you might think. A review of the ten top U.S. web sites shows that two of them contain a duplicated script. Two main factors increase the odds of a script being duplicated in a single web page: team size and number of scripts. When it does happen, duplicate scripts hurt performance by creating unnecessary HTTP requests and wasted JavaScript execution.</p><p>Unnecessary HTTP requests happen in Internet Explorer, but not in Firefox. In Internet Explorer, if an external script is included twice and is not cacheable, it generates two HTTP requests during page loading. Even if the script is cacheable, extra HTTP requests occur when the user reloads the page.</p><p>In addition to generating wasteful HTTP requests, time is wasted evaluating the script multiple times. This redundant JavaScript execution happens in both Firefox and Internet Explorer, regardless of whether the script is cacheable.</p><p>One way to avoid accidentally including the same script twice is to implement a script management module in your templating system. The typical way to include a script is to use the SCRIPT tag in your HTML page.</p><pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;menu_1.0.17.js&quot;&gt;&lt;/script&gt;</code></pre><p>An alternative in PHP would be to create a function called <code>insertScript</code>.</p><pre><code>&lt;?php insertScript(&quot;menu.js&quot;) ?&gt;</code></pre><p>In addition to preventing the same script from being inserted multiple times, this function could handle other issues with scripts, such as dependency checking and adding version numbers to script filenames to support far future Expires headers.</p>", "id": "ydupes", "title": "Remove Duplicate Scripts"}, {"content": "<p>Iframes allow an HTML document to be inserted in the parent document. It&rsquo;s important to understand how iframes work so they can be used effectively.</p><p><code>&amp;lt;iframe&amp;gt;</code> pros:</p><ul><li>Helps with slow third-party content like badges and ads</li><li>Security sandbox</li><li>Download scripts in parallel</li></ul><p>&lt;iframe&gt; cons:</p><ul><li>Costly even if blank</li><li>Blocks page onload</li><li>Non-semantic</li></ul>", "id": "yiframes", "title": "Minimize Number of iframes"}, {"content": "<p>Many of these performance rules deal with how external components are managed. However, before these considerations arise you should ask a more basic question: Should JavaScript and CSS be contained in external files, or inlined in the page itself?</p><p>Using external files in the real world generally produces faster pages because the JavaScript and CSS files are cached by the browser. JavaScript and CSS that are inlined in HTML documents get downloaded every time the HTML document is requested. This reduces the number of HTTP requests that are needed, but increases the size of the HTML document. On the other hand, if the JavaScript and CSS are in external files cached by the browser, the size of the HTML document is reduced without increasing the number of HTTP requests.</p><p>The key factor, then, is the frequency with which external JavaScript and CSS components are cached relative to the number of HTML documents requested. This factor, although difficult to quantify, can be gauged using various metrics. If users on your site have multiple page views per session and many of your pages re-use the same scripts and stylesheets, there is a greater potential benefit from cached external files.</p><p>Many web sites fall in the middle of these metrics. For these sites, the best solution generally is to deploy the JavaScript and CSS as external files. The only exception where inlining is preferable is with home pages, such as <a href=\"http://www.yahoo.com\">Yahoo!&rsquo;s front page</a> and <a href=\"http://my.yahoo.com\">My Yahoo!</a>. Home pages that have few (perhaps only one) page view per session may find that inlining JavaScript and CSS results in faster end-user response times.</p><p>For front pages that are typically the first of many page views, there are techniques that leverage the reduction of HTTP requests that inlining provides, as well as the caching benefits achieved through using external files. One such technique is to inline JavaScript and CSS in the front page, but dynamically download the external files after the page has finished loading. Subsequent pages would reference the external files that should already be in the browser&rsquo;s cache.</p>", "id": "yexternal", "title": "Make JavaScript and CSS External"}, {"content": "<p>HTTP cookies are used for a variety of reasons such as authentication and personalization. Information about cookies is exchanged in the HTTP headers between web servers and browsers. It&rsquo;s important to keep the size of cookies as low as possible to minimize the impact on the user&rsquo;s response time.</p><p>For more information check <a href=\"http://yuiblog.com/blog/2007/03/01/performance-research-part-3/\">&ldquo;When the Cookie Crumbles&rdquo;</a> by Tenni Theurer and Patty Chi. The take-home of this research:</p><ul><li>Eliminate unnecessary cookies</li><li>Keep cookie sizes as low as possible to minimize the impact on the user response time</li><li>Be mindful of setting cookies at the appropriate domain level so other sub-domains are not affected</li><li>Set an Expires date appropriately. An earlier Expires date or none removes the cookie sooner, improving the user response time</li></ul>", "id": "ymincookie", "title": "Reduce Cookie Size"}, {"content": "<p>CSS expressions are a powerful (and dangerous) way to set CSS properties dynamically. They were supported in Internet Explorer starting with version 5, but were <a href=\"http://msdn.microsoft.com/en-us/library/ms537634%28VS.85%29.aspx\">deprecated starting with IE8</a>. As an example, the background color could be set to alternate every hour using CSS expressions:</p><pre><code>background-color: expression( (new Date()).getHours()%2 ? &quot;#B8D4FF&quot; : &quot;#F08A00&quot; );</code></pre><p>As shown here, the <code>expression</code> method accepts a JavaScript expression. The CSS property is set to the result of evaluating the JavaScript expression. The <code>expression</code> method is ignored by other browsers, so it is useful for setting properties in Internet Explorer needed to create a consistent experience across browsers.</p><p>The problem with expressions is that they are evaluated more frequently than most people expect. Not only are they evaluated when the page is rendered and resized, but also when the page is scrolled and even when the user moves the mouse over the page. Adding a counter to the CSS expression allows us to keep track of when and how often a CSS expression is evaluated. Moving the mouse around the page can easily generate more than 10,000 evaluations.</p><p>One way to reduce the number of times your CSS expression is evaluated is to use one-time expressions, where the first time the expression is evaluated it sets the style property to an explicit value, which replaces the CSS expression. If the style property must be set dynamically throughout the life of the page, using event handlers instead of CSS expressions is an alternative approach. If you must use CSS expressions, remember that they may be evaluated thousands of times and could affect the performance of your page.</p>", "id": "yexpressions", "title": "Avoid CSS expressions"}, {"content": "<p>After a designer is done with creating the images for your web page, there are still some things you can try before you FTP those images to your web server.</p><ul><li>You can check the GIFs and see if they are using a palette size corresponding to the number of colors in the image. Using <a href=\"http://www.imagemagick.org\">imagemagick</a> it&rsquo;s easy to check using <code>identify -verbose image.gif</code> When you see an image using 4 colors and a 256 color &ldquo;slots&rdquo; in the palette, there is room for improvement.</li><li>Try converting GIFs to PNGs and see if there is a saving. More often than not, there is. Developers often hesitate to use PNGs due to the limited support in browsers, but this is now a thing of the past. The only real problem is alpha-transparency in true color PNGs, but then again, GIFs are not true color and don&rsquo;t support variable transparency either. So anything a GIF can do, a palette PNG (PNG8) can do too (except for animations). This simple imagemagick command results in totally safe-to-use PNGs: <code>convert image.gif image.png</code> &ldquo;All we are saying is: Give PiNG a Chance!&rdquo;</li><li>Run <a href=\"http://pmt.sourceforge.net/pngcrush/\">pngcrush</a> (or any other PNG optimizer tool) on all your PNGs. Example: <code>pngcrush image.png -rem alla -reduce -brute result.png</code></li><li>Run jpegtran on all your JPEGs. This tool does lossless JPEG operations such as rotation and can also be used to optimize and remove comments and other useless information (such as EXIF information) from your images. <code>jpegtran -copy none -optimize -perfect src.jpg dest.jpg</code></li></ul>", "id": "yopt_images", "title": "Optimize Images"}, {"content": "<ul><li>Arranging the images in the sprite horizontally as opposed to vertically usually results in a smaller file size.</li><li>Combining similar colors in a sprite helps you keep the color count low, ideally under 256 colors so to fit in a PNG8.</li><li>&ldquo;Be mobile-friendly&rdquo; and don&rsquo;t leave big gaps between the images in a sprite. This doesn&rsquo;t affect the file size as much but requires less memory for the user agent to decompress the image into a pixel map. 100x100 image is 10 thousand pixels, where 1000x1000 is 1 million pixels</li></ul>", "id": "yopt_sprites", "title": "Optimize CSS Sprites"}, {"content": "<p>When the browser makes a request for a static image and sends cookies together with the request, the server doesn&rsquo;t have any use for those cookies. So they only create network traffic for no good reason. You should make sure static components are requested with cookie-free requests. Create a subdomain and host all your static components there.</p><p>If your domain is <code>www.example.org</code>, you can host your static components on <code>static.example.org</code>. However, if you&rsquo;ve already set cookies on the top-level domain <code>example.org</code> as opposed to <code>www.example.org</code>, then all the requests to <code>static.example.org</code> will include those cookies. In this case, you can buy a whole new domain, host your static components there, and keep this domain cookie-free. Yahoo! uses <code>yimg.com</code>, YouTube uses <code>ytimg.com</code>, Amazon uses <code>images-amazon.com</code> and so on.</p><p>Another benefit of hosting static components on a cookie-free domain is that some proxies might refuse to cache the components that are requested with cookies. On a related note, if you wonder if you should use example.org or www.example.org for your home page, consider the cookie impact. Omitting www leaves you no choice but to write cookies to <code>*.example.org</code>, so for performance reasons it&rsquo;s best to use the www subdomain and write the cookies to that subdomain.</p>", "id": "ycookiefree", "title": "Use Cookie-Free Domains for Components"}, {"content": "<p>One of the cited benefits of Ajax is that it provides instantaneous feedback to the user because it requests information asynchronously from the backend web server. However, using Ajax is no guarantee that the user won&rsquo;t be twiddling his thumbs waiting for those asynchronous JavaScript and XML responses to return. In many applications, whether or not the user is kept waiting depends on how Ajax is used. For example, in a web-based email client the user will be kept waiting for the results of an Ajax request to find all the email messages that match their search criteria. It&rsquo;s important to remember that &ldquo;asynchronous&rdquo; does not imply &ldquo;instantaneous&rdquo;.</p><p>To improve performance, it&rsquo;s important to optimize these Ajax responses. The most important way to improve the performance of Ajax is to make the responses cacheable, as discussed in <a href=\"#expires\">Add an Expires or a Cache-Control Header</a>. Some of the other rules also apply to Ajax:</p><ul><li><a href=\"#gzip\">Gzip Components</a></li><li><a href=\"#dns_lookups\">Reduce DNS Lookups</a></li><li><a href=\"#minify\">Minify JavaScript</a></li><li><a href=\"#redirects\">Avoid Redirects</a></li><li><a href=\"#etags\">Configure ETags</a></li></ul><p>Let&rsquo;s look at an example. A Web 2.0 email client might use Ajax to download the user&rsquo;s address book for autocompletion. If the user hasn&rsquo;t modified her address book since the last time she used the email web app, the previous address book response could be read from cache if that Ajax response was made cacheable with a future Expires or Cache-Control header. The browser must be informed when to use a previously cached address book response versus requesting a new one. This could be done by adding a timestamp to the address book Ajax URL indicating the last time the user modified her address book, for example, <code>&amp;t=1190241612</code>. If the address book hasn&rsquo;t been modified since the last download, the timestamp will be the same and the address book will be read from the browser&rsquo;s cache eliminating an extra HTTP roundtrip. If the user has modified her address book, the timestamp ensures the new URL doesn&rsquo;t match the cached response, and the browser will request the updated address book entries.</p><p>Even though your Ajax responses are created dynamically, and might only be applicable to a single user, they can still be cached. Doing so will make your Web 2.0 apps faster.</p>", "id": "yxhr", "title": "Make Ajax Cacheable"}, {"content": "<p>When users request a page, it can take anywhere from 200 to 500ms for the backend server to stitch together the HTML page. During this time, the browser is idle as it waits for the data to arrive. In PHP you have the function <a href=\"http://php.net/flush\">flush()</a>. It allows you to send your partially ready HTML response to the browser so that the browser can start fetching components while your backend is busy with the rest of the HTML page. The benefit is mainly seen on busy backends or light frontends.</p><p>A good place to consider flushing is right after the HEAD because the HTML for the head is usually easier to produce and it allows you to include any CSS and JavaScript files for the browser to start fetching in parallel while the backend is still processing.</p><p>Example:</p><pre><code>    ... &lt;!-- css, js --&gt;    &lt;/head&gt;    &lt;?php flush(); ?&gt;    &lt;body&gt;      ... &lt;!-- content --&gt;</code></pre><p><a href=\"http://search.yahoo.com\">Yahoo! search</a> pioneered research and real user testing to prove the benefits of using this technique.</p>", "id": "yflush", "title": "Flush the Buffer Early"}, {"content": "<p>A complex page means more bytes to download and it also means slower DOM access in JavaScript. It makes a difference if you loop through 500 or 5000 DOM elements on the page when you want to add an event handler for example.</p><p>A high number of DOM elements can be a symptom that there&rsquo;s something that should be improved with the markup of the page without necessarily removing content. Are you using nested tables for layout purposes? Are you throwing in more <code>&lt;div&gt;</code>s only to fix layout issues? Maybe there&rsquo;s a better and more semantically correct way to do your markup.</p><p>A great help with layouts are the <a href=\"http://developer.yahoo.com/yui/\">YUI CSS utilities</a>: grids.css can help you with the overall layout, fonts.css and reset.css can help you strip away the browser&rsquo;s defaults formatting. This is a chance to start fresh and think about your markup, for example use <code>&lt;div&gt;</code>s only when it makes sense semantically, and not because it renders a new line.</p><p>The number of DOM elements is easy to test, just type in Firebug&rsquo;s console: <code>document.getElementsByTagName('*').length</code></p><p>And how many DOM elements are too many? Check other similar pages that have good markup. For example the <a href=\"http://www.yahoo.com\">Yahoo! Home Page</a> is a pretty busy page and still under 700 elements (HTML tags).</p>", "id": "ymindom", "title": "Reduce the Number of DOM Elements"}, {"content": "<p>The time it takes to transfer an HTTP request and response across the network can be significantly reduced by decisions made by front-end engineers. It&rsquo;s true that the end-user&rsquo;s bandwidth speed, Internet service provider, proximity to peering exchange points, etc. are beyond the control of the development team. But there are other variables that affect response times. Compression reduces response times by reducing the size of the HTTP response.</p><p>Starting with HTTP/1.1, web clients indicate support for compression with the Accept-Encoding header in the HTTP request.</p><pre><code>Accept-Encoding: gzip, deflate</code></pre><p>If the web server sees this header in the request, it may compress the response using one of the methods listed by the client. The web server notifies the web client of this via the Content-Encoding header in the response.</p><pre><code>Content-Encoding: gzip</code></pre><p>Gzip is the most popular and effective compression method at this time. It was developed by the GNU project and standardized by <a href=\"http://www.ietf.org/rfc/rfc1952.txt\">RFC 1952</a>. The only other compression format you&rsquo;re likely to see is deflate, but it&rsquo;s less effective and less popular.</p><p>Gzipping generally reduces the response size by about 70%. Approximately 90% of today&rsquo;s Internet traffic travels through browsers that claim to support gzip. If you use Apache, the module configuring gzip depends on your version: Apache 1.3 uses <a href=\"http://sourceforge.net/projects/mod-gzip/\">mod_gzip</a> while Apache 2.x uses <a href=\"http://httpd.apache.org/docs/2.0/mod/mod_deflate.html\">mod_deflate</a>.</p><p>There are known issues with browsers and proxies that may cause a mismatch in what the browser expects and what it receives with regard to compressed content. Fortunately, these edge cases are dwindling as the use of older browsers drops off. The Apache modules help out by adding appropriate Vary response headers automatically.</p><p>Servers choose what to gzip based on file type, but are typically too limited in what they decide to compress. Most web sites gzip their HTML documents. It&rsquo;s also worthwhile to gzip your scripts and stylesheets, but many web sites miss this opportunity. In fact, it&rsquo;s worthwhile to compress any text response including XML and JSON. Image and PDF files should not be gzipped because they are already compressed. Trying to gzip them not only wastes CPU but can potentially increase file sizes.</p><p>Gzipping as many file types as possible is an easy way to reduce page weight and accelerate the user experience.</p>", "id": "ycompress", "title": "Gzip Components"}, {"content": "<p>Splitting components allows you to maximize parallel downloads. Make sure you&rsquo;re using not more than 2-4 domains because of the DNS lookup penalty. For example, you can host your HTML and dynamic content on <code>www.example.org</code> and split static components between <code>static1.example.org</code> and <code>static2.example.org</code></p><p>For more information check &ldquo;<a href=\"http://yuiblog.com/blog/2007/04/11/performance-research-part-4/\">Maximizing Parallel Downloads in the Carpool Lane</a>&rdquo; by Tenni Theurer and Patty Chi.</p>", "id": "ysplit", "title": "Split Components Across Domains"}, {"content": "<p>The problem caused by scripts is that they block parallel downloads. The <a href=\"http://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html#sec8.1.4\">HTTP/1.1 specification</a> suggests that browsers download no more than two components in parallel per hostname. If you serve your images from multiple hostnames, you can get more than two downloads to occur in parallel. While a script is downloading, however, the browser won&rsquo;t start any other downloads, even on different hostnames.</p><p>In some situations it&rsquo;s not easy to move scripts to the bottom. If, for example, the script uses <code>document.write</code> to insert part of the page&rsquo;s content, it can&rsquo;t be moved lower in the page. There might also be scoping issues. In many cases, there are ways to workaround these situations.</p><p>An alternative suggestion that often comes up is to use deferred scripts. The <code>DEFER</code> attribute indicates that the script does not contain document.write, and is a clue to browsers that they can continue rendering. Unfortunately, Firefox doesn&rsquo;t support the <code>DEFER</code> attribute. In Internet Explorer, the script may be deferred, but not as much as desired. If a script can be deferred, it can also be moved to the bottom of the page. That will make your web pages load faster.</p>", "id": "yjsbottom", "title": "Put Scripts at Bottom"}, {"content": "<p>There are two aspects to this rule:</p><ul><li>For static components: implement &ldquo;Never expire&rdquo; policy by setting far future <code>Expires</code> header</li><li>For dynamic components: use an appropriate <code>Cache-Control</code> header to help the browser with conditional requests</li></ul><p>Web page designs are getting richer and richer, which means more scripts, stylesheets, images, and Flash in the page. A first-time visitor to your page may have to make several HTTP requests, but by using the Expires header you make those components cacheable. This avoids unnecessary HTTP requests on subsequent page views. Expires headers are most often used with images, but they should be used on <em>all</em> components including scripts, stylesheets, and Flash components.</p><p>Browsers (and proxies) use a cache to reduce the number and size of HTTP requests, making web pages load faster. A web server uses the Expires header in the HTTP response to tell the client how long a component can be cached. This is a far future Expires header, telling the browser that this response won&rsquo;t be stale until April 15, 2010.</p><pre><code>Expires: Thu, 15 Apr 2010 20:00:00 GMT</code></pre><p>If your server is Apache, use the ExpiresDefault directive to set an expiration date relative to the current date. This example of the ExpiresDefault directive sets the Expires date 10 years out from the time of the request.</p><pre><code>ExpiresDefault &quot;access plus 10 years&quot;</code></pre><p>Keep in mind, if you use a far future Expires header you have to change the component&rsquo;s filename whenever the component changes. At Yahoo! we often make this step part of the build process: a version number is embedded in the component&rsquo;s filename, for example, yahoo_2.0.6.js.</p><p>Using a far future Expires header affects page views only after a user has already visited your site. It has no effect on the number of HTTP requests when a user visits your site for the first time and the browser&rsquo;s cache is empty. Therefore the impact of this performance improvement depends on how often users hit your pages with a primed cache. (A &ldquo;primed cache&rdquo; already contains all of the components in the page.) We <a href=\"http://yuiblog.com/blog/2007/01/04/performance-research-part-2/\">measured this at Yahoo!</a> and found the number of page views with a primed cache is 75-85%. By using a far future Expires header, you increase the number of components that are cached by the browser and re-used on subsequent page views without sending a single byte over the user&rsquo;s Internet connection.</p>", "id": "yexpires", "title": "Add Expires or Cache-Control Header"}, {"content": "<p>Packing components into a multipart document is like an email with attachments, it helps you fetch several components with one HTTP request (remember: HTTP requests are expensive). When you use this technique, first check if the user agent supports it (iPhone does not).</p>", "id": "ymultipart", "title": "Pack Components into a Multipart Document"}, {"content": "<p>The <a href=\"http://mail.yahoo.com\">Yahoo! Mail</a> team found that when using <code>XMLHttpRequest</code>, POST is implemented in the browsers as a two-step process: sending the headers first, then sending data. So it&rsquo;s best to use GET, which only takes one TCP packet to send (unless you have a lot of cookies). The maximum URL length in IE is 2K, so if you send more than 2K data you might not be able to use GET.</p><p>An interesting side affect is that POST without actually posting any data behaves like GET. Based on the <a href=\"http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html\">HTTP specs</a>, GET is meant for retrieving information, so it makes sense (semantically) to use GET when you&rsquo;re only requesting data, as opposed to sending data to be stored server-side.</p>", "id": "yxhrmethod", "title": "Use GET for AJAX Requests"}, {"content": "<p>80% of the end-user response time is spent on the front-end. Most of this time is tied up in downloading all the components in the page: images, stylesheets, scripts, Flash, etc. Reducing the number of components in turn reduces the number of HTTP requests required to render the page. This is the key to faster pages.</p><p>One way to reduce the number of components in the page is to simplify the page&rsquo;s design. But is there a way to build pages with richer content while also achieving fast response times? Here are some techniques for reducing the number of HTTP requests, while still supporting rich page designs.</p><p><strong>Combined files</strong> are a way to reduce the number of HTTP requests by combining all scripts into a single script, and similarly combining all CSS into a single stylesheet. Combining files is more challenging when the scripts and stylesheets vary from page to page, but making this part of your release process improves response times.</p><p><a href=\"http://alistapart.com/articles/sprites\"><strong>CSS Sprites</strong></a> are the preferred method for reducing the number of image requests. Combine your background images into a single image and use the CSS <code>background-image</code> and <code>background-position</code> properties to display the desired image segment.</p><p><a href=\"http://www.w3.org/TR/html401/struct/objects.html#h-13.6\"><strong>Image maps</strong></a> combine multiple images into a single image. The overall size is about the same, but reducing the number of HTTP requests speeds up the page. Image maps only work if the images are contiguous in the page, such as a navigation bar. Defining the coordinates of image maps can be tedious and error prone. Using image maps for navigation is not accessible too, so it&rsquo;s not recommended.</p><p><strong>Inline images</strong> use the <a href=\"http://tools.ietf.org/html/rfc2397\"><code>data:</code> URL scheme</a> to embed the image data in the actual page. This can increase the size of your HTML document. Combining inline images into your (cached) stylesheets is a way to reduce HTTP requests and avoid increasing the size of your pages. Inline images are not yet supported across all major browsers.</p><p>Reducing the number of HTTP requests in your page is the place to start. This is the most important guideline for improving performance for first time visitors. As described in Tenni Theurer&rsquo;s blog post <a href=\"http://yuiblog.com/blog/2007/01/04/performance-research-part-2/\">Browser Cache Usage - Exposed!</a>, 40-60% of daily visitors to your site come in with an empty cache. Making your page fast for these first time visitors is key to a better user experience.</p>", "id": "ynumreq", "title": "Make Fewer HTTP requests"}, {"content": "<p>Accessing DOM elements with JavaScript is slow so in order to have a more responsive page, you should:</p><ul><li>Cache references to accessed elements</li><li>Update nodes &ldquo;offline&rdquo; and then add them to the tree</li><li>Avoid fixing layout with JavaScript</li></ul><p>For more information check the YUI theatre&rsquo;s <a href=\"http://yuiblog.com/blog/2007/12/20/video-lecomte/\">&ldquo;High Performance Ajax Applications&rdquo;</a> by Julien Lecomte.</p>", "id": "ydom_access", "title": "Minimize DOM Access"}, {"content": "<p>Don&rsquo;t use a bigger image than you need just because you can set the width and height in HTML. If you need <code>&lt;img width=&quot;100&quot; height=&quot;100&quot; src=&quot;mycat.jpg&quot; alt=&quot;My Cat&quot; /&gt;</code> then your image (mycat.jpg) should be 100x100px rather than a scaled down 500x500px image.</p>", "id": "yimgnoscale", "title": "Do Not Scale Images in HTML"}, {"content": "<p>The IE-proprietary <code>AlphaImageLoader</code> filter aims to fix a problem with semi-transparent true color PNGs in IE versions &lt; 7. The problem with this filter is that it blocks rendering and freezes the browser while the image is being downloaded. It also increases memory consumption and is applied per element, not per image, so the problem is multiplied.</p><p>The best approach is to avoid <code>AlphaImageLoader</code> completely and use gracefully degrading PNG8 instead, which are fine in IE. If you absolutely need <code>AlphaImageLoader</code>, use the underscore hack <code>_filter</code> as to not penalize your IE7+ users.</p>", "id": "ynofilter", "title": "Avoid Filters"}, {"content": "<p>The favicon.ico is an image that stays in the root of your server. It&rsquo;s a necessary evil because even if you don&rsquo;t care about it the browser will still request it, so it&rsquo;s better not to respond with a <code>404 Not Found</code>. Also since it&rsquo;s on the same server, cookies are sent every time it&rsquo;s requested. This image also interferes with the download sequence, for example in IE when you request extra components in the onload, the favicon will be downloaded before these extra components.</p><p>So to mitigate the drawbacks of having a favicon.ico make sure:</p><ul><li>It&rsquo;s small, preferably under 1K.</li><li>Set Expires header with what you feel comfortable (since you cannot rename it if you decide to change it). You can probably safely set the Expires header a few months in the future. You can check the last modified date of your current favicon.ico to make an informed decision.</li></ul><p><a href=\"http://www.imagemagick.org\">Imagemagick</a> can help you create small favicons</p>", "id": "yfavicon", "title": "Make favicon.ico Small and Cacheable"}, {"content": "<p>The user&rsquo;s proximity to your web server has an impact on response times. Deploying your content across multiple, geographically dispersed servers will make your pages load faster from the user&rsquo;s perspective. But where should you start?</p><p>As a first step to implementing geographically dispersed content, don&rsquo;t attempt to redesign your web application to work in a distributed architecture. Depending on the application, changing the architecture could include daunting tasks such as synchronizing session state and replicating database transactions across server locations. Attempts to reduce the distance between users and your content could be delayed by, or never pass, this application architecture step.</p><p>Remember that 80-90% of the end-user response time is spent downloading all the components in the page: images, stylesheets, scripts, Flash, etc. This is the <em>Performance Golden Rule</em>. Rather than starting with the difficult task of redesigning your application architecture, it&rsquo;s better to first disperse your static content. This not only achieves a bigger reduction in response times, but it&rsquo;s easier thanks to content delivery networks.</p><p>A content delivery network (CDN) is a collection of web servers distributed across multiple locations to deliver content more efficiently to users. The server selected for delivering content to a specific user is typically based on a measure of network proximity. For example, the server with the fewest network hops or the server with the quickest response time is chosen.</p><p>Some large Internet companies own their own CDN, but it&rsquo;s cost-effective to use a CDN service provider, such as <a href=\"http://www.akamai.com/\">Akamai Technologies</a>, <a href=\"http://www.edgecast.com/\">EdgeCast</a>, or <a href=\"http://www.level3.com/index.cfm?pageID=36\">level3</a>. For start-up companies and private web sites, the cost of a CDN service can be prohibitive, but as your target audience grows larger and becomes more global, a CDN is necessary to achieve fast response times. At Yahoo!, properties that moved static content off their application web servers to a CDN (both 3rd party as mentioned above as well as Yahoo\u2019s own <a href=\"https://cwiki.apache.org/TS/traffic-server.html\">CDN</a>) improved end-user response times by 20% or more. Switching to a CDN is a relatively easy code change that will dramatically improve the speed of your web site.</p>", "id": "ycdn", "title": "Use a Content Delivery Network (CDN)"}, {"content": "<p>Redirects are accomplished using the 301 and 302 status codes. Here&rsquo;s an example of the HTTP headers in a 301 response:</p><pre><code>HTTP/1.1 301 Moved PermanentlyLocation: http://example.com/newuriContent-Type: text/html</code></pre><p>The browser automatically takes the user to the URL specified in the <code>Location</code> field. All the information necessary for a redirect is in the headers. The body of the response is typically empty. Despite their names, neither a 301 nor a 302 response is cached in practice unless additional headers, such as <code>Expires</code> or <code>Cache-Control</code>, indicate it should be. The meta refresh tag and JavaScript are other ways to direct users to a different URL, but if you must do a redirect, the preferred technique is to use the standard 3xx HTTP status codes, primarily to ensure the back button works correctly.</p><p>The main thing to remember is that redirects slow down the user experience. Inserting a redirect between the user and the HTML document delays everything in the page since nothing in the page can be rendered and no components can start being downloaded until the HTML document has arrived.</p><p>One of the most wasteful redirects happens frequently and web developers are generally not aware of it. It occurs when a trailing slash (/) is missing from a URL that should otherwise have one. For example, going to <a href=\"http://astrology.yahoo.com/astrology\">http://astrology.yahoo.com/astrology</a> results in a 301 response containing a redirect to <a href=\"http://astrology.yahoo.com/astrology/\">http://astrology.yahoo.com/astrology/</a> (notice the added trailing slash). This is fixed in Apache by using <code>Alias</code> or <code>mod_rewrite</code>, or the <code>DirectorySlash</code> directive if you&rsquo;re using Apache handlers.</p><p>Connecting an old web site to a new one is another common use for redirects. Others include connecting different parts of a website and directing the user based on certain conditions (type of browser, type of user account, etc.). Using a redirect to connect two web sites is simple and requires little additional coding. Although using redirects in these situations reduces the complexity for developers, it degrades the user experience. Alternatives for this use of redirects include using <code>Alias</code> and <code>mod_rewrite</code> if the two code paths are hosted on the same server. If a domain name change is the cause of using redirects, an alternative is to create a CNAME (a DNS record that creates an alias pointing from one domain name to another) in combination with <code>Alias</code> or <code>mod_rewrite</code>.</p>", "id": "yredirects", "title": "Avoid Redirects"}, {"content": "<p>Minification is the practice of removing unnecessary characters from code to reduce its size thereby improving load times. When code is minified all comments are removed, as well as unneeded white space characters (space, newline, and tab). In the case of JavaScript, this improves response time performance because the size of the downloaded file is reduced. Two popular tools for minifying JavaScript code are <a href=\"http://crockford.com/javascript/jsmin\">JSMin</a> and <a href=\"http://developer.yahoo.com/yui/compressor/\">YUI Compressor</a>. The YUI compressor can also minify CSS.</p><p>Obfuscation is an alternative optimization that can be applied to source code. It&rsquo;s more complex than minification and thus more likely to generate bugs as a result of the obfuscation step itself. In a survey of ten top U.S. web sites, minification achieved a 21% size reduction versus 25% for obfuscation. Although obfuscation has a higher size reduction, minifying JavaScript is less risky.</p><p>In addition to minifying external scripts and styles, inlined <code>&lt;script&gt;</code> and <code>&lt;style&gt;</code> blocks can and should also be minified. Even if you gzip your scripts and styles, minifying them will still reduce the size by 5% or more. As the use and size of JavaScript and CSS increases, so will the savings gained by minifying your code.</p>", "id": "yminify", "title": "Minify JavaScript and CSS"}]}