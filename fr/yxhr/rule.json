{"content": "<p>Un des avantages cit\u00e9s d&rsquo;Ajax est qu&rsquo;il fournit une r\u00e9troaction instantan\u00e9e \u00e0 l&rsquo;utilisateur car il demande des informations de mani\u00e8re asynchrone \u00e0 partir du serveur Web. Cependant, utiliser Ajax n&rsquo;est pas une garantie que l&rsquo;utilisateur ne sera pas en train de se tourner les pouces en attendant le retour des r\u00e9ponses Asynchronous JavaScript and XML. Dans de nombreuses applications, maintenir l&rsquo;attente de l&rsquo;utilisateur d\u00e9pend de la fa\u00e7on dont Ajax est utilis\u00e9. Par exemple, dans un client de messagerie bas\u00e9 sur le Web, l&rsquo;utilisateur sera maintenu en attendant les r\u00e9sultats d&rsquo;une requ\u00eate Ajax pour trouver tous les messages \u00e9lectroniques correspondant aux crit\u00e8res de recherche. Il est important de se rappeler que \u00abasynchrone\u00bb ne signifie pas \u00abinstantan\u00e9\u00bb.</p><p>Pour am\u00e9liorer les performances, il est important d&rsquo;optimiser ces r\u00e9ponses Ajax. Le moyen le plus important pour am\u00e9liorer les performances Ajax est de servir les r\u00e9ponses mises en cache, comme indiqu\u00e9 dans <a href=\"# expire\">Ajouter une expiration ou un en-t\u00eate Cache-Control</a>. D&rsquo;autres r\u00e8gles s&rsquo;appliquent \u00e9galement \u00e0 pour Ajax:</p><ul><li><a href=\"#gzip\">Gzipper les composants</a></li><li><a href=\"#dns_lookups\">R\u00e9duire le nombre de requ\u00eates DNS</a></li><li><a href=\"#minify\">Minifier JavaScript</a></li><li><a href=\"#redirects\">\u00c9viter les redirections</a></li><li><a href=\"#etags\">Configurer les ETags</a></li></ul><p>Voyons un exemple. Un client de messagerie Web 2.0 peut utiliser Ajax pour t\u00e9l\u00e9charger le carnet d&rsquo;adresses de l&rsquo;utilisateur \u00e0 des fins d&rsquo;auto-compl\u00e9tion. Si l&rsquo;utilisateur n&rsquo;a pas modifi\u00e9 son carnet d&rsquo;adresse depuis la derni\u00e8re fois, la r\u00e9ponse du carnet d&rsquo;adresses pr\u00e9c\u00e9dente pourrait \u00eatre lue \u00e0 partir du cache si cette r\u00e9ponse Ajax a \u00e9t\u00e9 mise en cache avec un en-t\u00eate Expire ou Cache-Control. Le navigateur doit \u00eatre inform\u00e9 quand utiliser une r\u00e9ponse de carnet d&rsquo;adresses pr\u00e9c\u00e9demment mise en cache par rapport \u00e0 en demander une nouvelle. Cela pourrait se faire par l&rsquo;ajout d&rsquo;un horodatage dans le carnet d&rsquo;adresse URL Ajax indiquant la derni\u00e8re fois que l&rsquo;utilisateur a modifi\u00e9 son carnet d&rsquo;adresses. Par exemple, <code>&amp;t=1190241612</code>. Si le carnet d&rsquo;adresses n&rsquo;a pas \u00e9t\u00e9 modifi\u00e9 depuis le dernier t\u00e9l\u00e9chargement, l&rsquo;horodatage sera le m\u00eame et le carnet d&rsquo;adresses sera lu \u00e0 partir de la m\u00e9moire cache du navigateur, \u00e9liminant un aller-retour HTTP suppl\u00e9mentaire. Si l&rsquo;utilisateur a modifi\u00e9 son carnet d&rsquo;adresses, l&rsquo;horodatage assure que la nouvelle URL ne correspond pas \u00e0 la r\u00e9ponse mise en cache, et le navigateur demandera une nouvelle r\u00e9ponse du carnet d&rsquo;adresses \u00e0 jour .</p><p>M\u00eame si vos r\u00e9ponses Ajax sont cr\u00e9\u00e9es dynamiquement, et qu&rsquo;elles ne sontt applicables qu&rsquo;\u00e0 un seul utilisateur, elles peuvent encore \u00eatre mises en cache. Cela rendra vos applications Web 2.0 plus rapides.</p>", "id": "yxhr", "title": "Rendre les requ\u00eates Ajax cachables"}